#+OPTIONS: toc:nil
* My Personal Config
** Installation
This is my personal emacs configuration written in a literate-programming style. To generate the config tangle this file with org-babel-tangle (~C-c C-v t~).

Some of the code blocks pertain to the OS and will be tangled automatically. There are several blocks for Linux that pertain to running emacs as a window manager. These blocks can be found in [[X Window Manager][this section]].

*** Global Configs
#+NAME: config
#+BEGIN_SRC emacs-lisp :tangle ~/.emacs-config
  (defvar *home-dir*              (getenv "HOME"))
  (defvar *dotemacs-dir*          (concat *home-dir* "/src/dotemacs/"))
  (defvar *node-dir*              (concat *home-dir* "/.nvm/versions/node/v10.8.0/bin/"))
  (defvar *org-dir*               (concat *home-dir* "/org/"))
  (defvar *tsserver*              (concat *home-dir* "/src/TypeScript/lib/tsserver.js"))

  ;; x11 desktop specific
  (defvar *screenshot-dir*        (concat *home-dir* "/Pictures/")) ; used only for x11 desktops
  (defvar *amixer-path*           (concat "/usr/bin/amixer"))
#+END_SRC

* Configuration
#+TOC: headlines 2

** Initialization
Load the config if it exists, otherwise load the sample
#+BEGIN_SRC emacs-lisp :tangle ~/.emacs
  (if (file-exists-p "~/.emacs-config")
      (load-file "~/.emacs-config"))
#+END_SRC

*** Package Sources
Setting up basic repositories and [[https://github.com/jwiegley/use-package][use-package]].
#+BEGIN_SRC emacs-lisp  :tangle ~/.emacs
  (package-initialize)
  (require 'package)
  (setq package-enable-at-startup nil)
  (setq package-archives '(
			   ("marmalade"  . "http://marmalade-repo.org/packages/")
			   ("melpa-stable" . "http://stable.melpa.org/packages/")
			   ("gnu" . "http://elpa.gnu.org/packages/")
			   ;; ("org" . "https://orgmode.org/elpa/")
			   ("melpa" . "https://melpa.org/packages/")))
#+END_SRC

*** use-package Setup
#+BEGIN_SRC emacs-lisp :tangle ~/.emacs
  (unless (package-installed-p 'use-package)
    (package-refresh-contents)
    (package-install 'use-package))

  (require 'use-package-ensure)
  (setq use-package-always-ensure t)
#+END_SRC

Allow use-package to install missing system packages
#+BEGIN_SRC emacs-lisp
(use-package use-package-ensure-system-package
  :ensure t)
#+END_SRC

*** Personal Information
For the sake of completeness, configure name and email address
#+BEGIN_SRC emacs-lisp  :tangle ~/.emacs
  (setq user-full-name "Jeremy Gooch"
        user-mail-address "jeremy.gooch@gmail.com")
#+END_SRC

Setup a prefix for custom commands.
#+BEGIN_SRC emacs-lisp :tangle ~/.emacs
  (progn (define-prefix-command 'jrm-key-map))
  (global-set-key (kbd "C-x C-j") jrm-key-map)
#+END_SRC

** General Configuration
*** Basic Emacs Settings Preferences
I prefer emacs to just ask y/n not yes/no
 #+BEGIN_SRC emacs-lisp :tangle ~/.emacs
   (fset 'yes-or-no-p 'y-or-n-p)
 #+END_SRC

When killing a buffer always pick the current buffer by default
#+BEGIN_SRC emacs-lisp  :tangle ~/.emacs
  (defun kill-current-buffer ()
    "Kills the current buffer."
    (interactive)
    (kill-buffer (current-buffer)))
  (global-set-key (kbd "C-x k") 'kill-current-buffer)
#+END_SRC

Prevent async shell command buffers from popping-up:
#+BEGIN_SRC emacs-lisp :tangle ~/.emacs
  (add-to-list 'display-buffer-alist
    '("\\*Async Shell Command\\*.*" display-buffer-no-window))
#+END_SRC

Fix emacs' regex
#+BEGIN_SRC emacs-lisp :tangle ~/.emacs
  (setq-default pcre-mode t)
#+END_SRC

Use aspell for Mac (aspell can be installed with brew)
#+BEGIN_SRC emacs-lisp :tangle (if (string-equal system-type "darwin") "~/.emacs")
(setq ispell-program-name "/usr/local/bin/aspell")
#+END_SRC

Silence alarms
#+BEGIN_SRC emacs-lisp :tangle ~/.emacs
  (setq ring-bell-function 'ignore)
#+END_SRC

*** Dired
Some basic Dired setup
#+BEGIN_SRC emacs-lisp :tangle ~/.emacs
  (global-auto-revert-mode 1)
  (setq global-auto-revert-non-file-buffers t)
  (setq auto-revert-verbose nil)
  (setq dired-listing-switches "-alh")
#+END_SRC

It's nice to be able to tab through directories in dired, and I'm a sucker for eye candy with icons
#+BEGIN_SRC emacs-lisp :tangle ~/.emacs
  (defun jrm/dired-subtree-toggle-and-refresh ()
    "Calls dired toggle and refreshes the buffer."
    (interactive)
    (dired-subtree-toggle)
    (revert-buffer))

  (use-package dired-subtree
    :after dired
    :config
    (bind-key "<tab>" #'jrm/dired-subtree-toggle-and-refresh dired-mode-map)
    (bind-key "<backtab>" #'dired-subtree-cycle dired-mode-map))

  (use-package all-the-icons-dired)
  (add-hook 'dired-mode-hook 'all-the-icons-dired-mode)
#+END_SRC

*** Tramp
#+BEGIN_SRC emacs-lisp :tangle ~/.emacs
  (use-package tramp :config (setq tramp-default-method "scp"))
#+END_SRC

*** Grep
Ignore certain directories by default for grep
#+BEGIN_SRC emacs-lisp :tangle ~/.emacs
  (custom-set-variables
   '(grep-find-ignored-directories
     (quote
      ("SCCS" "RCS" "CVS" "MCVS" ".src" ".svn" ".git" ".hg" ".bzr" "_MTN" "_darcs" "{arch}" "node_modules" "vendor"))))
#+END_SRC

*** IBuffer
#+BEGIN_SRC emacs-lisp  :tangle ~/.emacs
	(global-set-key (kbd "C-x C-b") 'ibuffer)
	(setq ibuffer-saved-filter-groups
	(quote (("default"
		 ("dired" (mode . dired-mode))
		 ("org" (mode . org-mode))
		 ("shell" (mode . shell-mode))
		 ("git" (name . "^magit\*"))
		 ("Slack" (or (mode . slack-mode)
						(name . "^\\*Slack.*$")))
		 ("email" (name . "^\\*mu4e-.*\\*$"))
		 ("ecmascript" (or (mode . javascript-mode)
					 (name . "^.*.js$")
					 (name . "^.*.ts")
					 (name . "^.*.json$")))
		 ("markup" (or (mode . web-mode)
						 (name . "^.*.tpl")
						 (name . "^.*.mst")
						 (name . "^.*.html")))
		 ("images" (name . "^.*png$"))
		 ("process" (or (mode . grep-mode)
				(name . "^\\*tramp*$")))
		 ("emacs" (or (name . "^\\*scratch\\*$")
						(name . "^\\*Messages\\*$")
						(name . "^\\*eww\\*$")
						(name . "^\\*GNU Emacs\\*$")))))))
	(add-hook 'ibuffer-mode-hook (lambda () (ibuffer-switch-to-saved-filter-groups "default")))
#+END_SRC

*** GPG Pinentry
Instead of using the display's popup, prompt for gpg creds in the minibuffer
#+BEGIN_SRC emacs-lisp  :tangle ~/.emacs
  (setq epa-pinentry-mode 'loopback)
#+END_SRC

*** Company mode
#+BEGIN_SRC emacs-lisp  :tangle ~/.emacs
  (use-package company :diminish company-mode
    :init (add-hook 'after-init-hook 'global-company-mode))
#+END_SRC

Company-mode with icons
#+BEGIN_SRC emacs-lisp :tangle ~/.emacs
(use-package company-box
  :hook (company-mode . company-box-mode)
  :diminish company-box-mode)
(setq company-idle-delay 0.2)
#+END_SRC

** Introspection
*** Ivy/Counsel/Swiper
Generic auto-complete with Ivy which 
 #+BEGIN_SRC emacs-lisp  :tangle ~/.emacs
   (use-package ivy :demand
     :diminish ivy-mode
     :config
     (setq ivy-use-virtual-buffers t
	   ivy-count-format "%d/%d ")
     (global-set-key (kbd "C-x b") 'ivy-switch-buffer))
   (ivy-mode 1)
   (setq ivy-use-selectable-prompt t)
 #+END_SRC

 Ivy enhanced search (swiper) and common Emacs meta commands (counsel)
 #+BEGIN_SRC emacs-lisp  :tangle ~/.emacs
   (use-package counsel
     :config
     (global-set-key (kbd "M-x") 'counsel-M-x)
     (global-set-key (kbd "C-M-SPC") 'counsel-git))

   (use-package swiper
     :config
     (global-set-key (kbd "C-s") 'swiper-isearch))
 #+END_SRC


** Introspection

*** Which key
Some quick help for when I get stuck in the middle of a command
#+BEGIN_SRC emacs-lisp :tangle ~/.emacs
  (use-package which-key :config (which-key-mode))
#+END_SRC



** File Editing/Navigation
*** General Settings
 Keep temporary and backup buffers out of current directory like a civilized human being.
 #+BEGIN_SRC emacs-lisp :tangle ~/.emacs
   (custom-set-variables
    '(auto-save-file-name-transforms '((".*" "~/.emacs.d/autosaves/\\1" t)))
    '(backup-directory-alist '((".*" . "~/.emacs.d/backups/")))
    '(delete-old-versions t))

   (make-directory "~/.emacs.d/autosaves/" t)
 #+END_SRC

 Disable the narrow-to-region message
 #+BEGIN_SRC emacs-lisp :tangle ~/.emacs
   (put 'narrow-to-region 'disabled nil)
 #+END_SRC

Replace region with next keystroke.
#+BEGIN_SRC emacs-lisp :tangle ~/.emacs
  (delete-selection-mode 1)
#+END_SRC

*** In-file Navigation
Easier paragraph jumping
 #+BEGIN_SRC emacs-lisp :tangle ~/.emacs
   (global-set-key (kbd "M-p") 'backward-paragraph)
   (global-set-key (kbd "M-n") 'forward-paragraph)
 #+END_SRC

Avy is great for speed-of-thought navigation
 #+BEGIN_SRC emacs-lisp :tangle ~/.emacs
   (use-package avy)
   (global-set-key (kbd "M-s") 'avy-goto-char)
   (global-set-key (kbd "C-c SPC") 'avy-goto-line)
 #+END_SRC

Turn on linum mode for almost everything.
#+BEGIN_SRC emacs-lisp :tangle ~/.emacs
  (global-set-key (kbd "C-c l l") 'display-line-numbers-mode)
#+END_SRC

Adjust the local mark ring pop key sequence, so after pressing `C-u C-SPC`, you can just press `C-SPC` to keep jumping.
#+BEGIN_SRC emacs-lisp :tangle ~/.emacs
  (setq set-mark-command-repeat-pop t)
#+END_SRC

*** Programming
#+BEGIN_SRC emacs-lisp :tangle ~/.emacs
  (use-package lsp-mode
	  :hook (ng2-ts-mode . lsp)
	  :hook (typescript-mode . lsp)
	  :hook (html-mode . lsp)
	  :hook (scss-mode . lsp)
	  :hook (sass-mode . lsp)
	  :hook (css-mode . lsp)
	  :hook (web-mode . lsp)
	  :hook (clojure-mode . lsp)
	  :commands lsp
	  :config
	  (dolist (m '(clojure-mode
		       clojurec-mode
		       clojurescript-mode
		       clojurex-mode))
	    (add-to-list 'lsp-language-id-configuration `(,m . "clojure"))))

  ;; optionally
  (use-package lsp-ui :commands lsp-ui-mode)
  (use-package company-lsp :commands company-lsp)
  (push 'company-lsp company-backends)
  (use-package helm-lsp :commands helm-lsp-workspace-symbol)
  (use-package lsp-treemacs :commands lsp-treemacs-errors-list)
  ;; optionally if you want to use debugger
  (use-package dap-mode)
  ;; (use-package dap-LANGUAGE) to load the dap adapter for your language
#+END_SRC

**** Lisps
Paredit for maintaining sanity while working with lisp
#+BEGIN_SRC emacs-lisp :tangle ~/.emacs
  (defun paredit-enable-modes () (add-hook 'emacs-lisp-mode-hook 'paredit-mode))

  (use-package paredit :config (paredit-enable-modes))
#+END_SRC

Some general settings for lisp dialects (elisp, clojure, etc).
#+BEGIN_SRC emacs-lisp :tangle ~/.emacs
  (autoload 'enable-paredit-mode "paredit" "Turn on pseudo-structural editing of Lisp code." t)
  (add-hook 'emacs-lisp-mode-hook       #'enable-paredit-mode)
  (add-hook 'eval-expression-minibuffer-setup-hook #'enable-paredit-mode)
  (add-hook 'ielm-mode-hook             #'enable-paredit-mode)
  (add-hook 'lisp-mode-hook             #'enable-paredit-mode)
  (add-hook 'lisp-interaction-mode-hook #'enable-paredit-mode)
  (add-hook 'scheme-mode-hook           #'enable-paredit-mode)
  (add-hook 'clojure-mode-hook          #'enable-paredit-mode)
#+End_SRC

***** elisp
Make evaluating elisp buffers even quicker
#+BEGIN_SRC emacs-lisp :tangle ~/.emacs
  (global-set-key (kbd "C-c C-e")  'eval-buffer)
#+END_SRC
***** Clojure Development
Clojure with Cider for interactive Clojure development
#+BEGIN_SRC emacs-lisp
  (use-package clojure-mode
    :defer
    :config
    (add-to-list 'auto-mode-alist '("\\.edn$" . clojure-mode))
    (add-to-list 'auto-mode-alist '("\\.boot$" . clojure-mode))
    (add-to-list 'auto-mode-alist '("\\.cljs.*$" . clojure-mode))
    (add-to-list 'auto-mode-alist '("lein-env" . enh-ruby-mode)))

  (use-package eldoc :diminish eldoc-mode)

  (use-package cider
    :defer
    :config
    (add-hook 'cider-repl-mode-hook #'eldoc-mode)
    (setq cider-repl-pop-to-buffer-on-connect t) ;; go to the repl when done connecting
    (setq cider-show-error-buffer t)
    (setq cider-auto-select-error-buffer t)) ;; jump to error message
#+END_SRC

****** Clojure/Quil Workflow Customization
A popup HSV color picker is helpful for quick prototyping/sketching
#+BEGIN_SRC emacs-lisp :tangle ~/.emacs
  (defun convert-range-360 (val)
    "Converts a value from a 0-1 range to 0-360 range. Used for calculating hue."
    (* (/ (- val 0) (- 1 0)) (+ (- 360 0) 0)))

  (defun jrm/insert-color-hsb ()
    "Select a color and insert its hue/saturation/brightness[lumenosity] format."
    (interactive "*")
    (let ((buf (current-buffer)))
      (custom-set-variables '(list-colors-sort (quote hsv)))
      (list-colors-display
       nil nil `(lambda (name)
		  (interactive)
		  (quit-window)
		  (with-current-buffer ,buf
		    (setq hsb (apply 'color-rgb-to-hsl (color-name-to-rgb name)))
		    (setq hue (convert-range-360 (nth 0 hsb)))
		    (setq sat (* 100 (nth 1 hsb)))
		    (insert (format "%s" hue 100) " " (format "%s" sat) " " (format "%s" 100.0)))))))
  (global-set-key (kbd "C-x C-j H")  'jrm/insert-color-hsb)
#+END_SRC

**** ECMAScript
Tern is a require package and can be installed with ~sudo npm install -g tern~

***** General Settings
Some basic code folding
#+BEGIN_SRC emacs-lisp :tangle ~/.emacs
  (use-package yafolding
    :hook ((ng2-ts-mode . yafolding-mode)
	   (js-mode . yafolding-mode)
	   (fundamental-mode . yafolding-mode)))
#+END_SRC

Use js2 mode rather than the built in javascript mode.
#+BEGIN_SRC emacs-lisp :tangle ~/.emacs
  (use-package js2-mode
    :defer
    :init
    (add-to-list 'auto-mode-alist '("\\.js\\'" . js2-mode)))


  ;; (add-hook 'js2-mode-hook #'setup-tide-mode)
  ;;   ;; configure javascript-tide checker to run after your default javascript checker
  ;;   (flycheck-add-next-checker 'javascript-eslint 'javascript-tide 'append)
#+END_SRC

Setup ECMA unicode glyphs
#+BEGIN_SRC emacs-lisp :tangle ~/.emacs
  (defun jrm/ecma-prettify-symbols ()
    "Adds common ECMA symobls to prettify-symbols-alist."
    (push '(">=" . ?≥) prettify-symbols-alist)
    (push '("=>" . ?⇒) prettify-symbols-alist)
    (push '("<=" . ?≤) prettify-symbols-alist)
    (push '("===" . ?≡) prettify-symbols-alist)
    (push '("!=" . ?≠) prettify-symbols-alist)
    (push '("!==" . ?≢) prettify-symbols-alist)
    (push '("&&" . ?∧) prettify-symbols-alist)
    (push '("||" . ?∥) prettify-symbols-alist)
    (prettify-symbols-mode))

  (add-hook 'js2-mode-hook 'jrm/ecma-prettify-symbols)
  (add-hook 'js-mode-hook 'jrm/ecma-prettify-symbols)
#+END_SRC

Web Beautify for unminifying assets
#+BEGIN_SRC emacs-lisp :tangle ~/.emacs
  (use-package web-beautify)
#+END_SRC

***** Tern Server Setup
[[https://ternjs.net/doc/manual.html][Tern]] is a great general js development package. Setup a global standard configuration. This can be overwritten on a project level by creating a ~.tern-project~ file.
#+BEGIN_SRC json :tangle ~/.tern-config
{
  "ecmaVersion": 2018,
  "libs": [
    "ecmascript",
    "browser"
  ],
  "plugins": {
    "modules": {},
    "es_modules": {},
    "node": {},
    "doc_comment": {
      "fullDocs": true,
      "strong": true
    }
  }
}
#+END_SRC

Use tern and company-tern for better js parsing. Tern can be installed with can be installed with ~sudo npm install -g tern~.
#+BEGIN_SRC emacs-lisp :tangle ~/.emacs
  (use-package company-tern
    :init
    (add-hook 'js2-mode-hook (lambda () (tern-mode) (company-mode))))
#+END_SRC

***** Angular/TS Development
#+BEGIN_SRC emacs-lisp :tangle ~/.emacs
  (setq exec-path (append exec-path '(*node-dir*)))
  (custom-set-variables
   '(flycheck-typescript-tslint-executable (concat *node-dir* "tslint"))
   '(tide-tsserver-executable *tsserver*)
   '(tide-node-executable (concat *node-dir* "node")))
  (use-package ng2-mode)
  (use-package flycheck :diminish flycheck-mode)
  (use-package tide :diminish tide-mode
    :config
    (defun setup-tide-mode ()
      (interactive)
      (tide-setup)
      (flycheck-mode +1)
      (setq flycheck-check-syntax-automatically '(save mode-enabled))
      (eldoc-mode +1)
      (tide-hl-identifier-mode +1)
      ;; company is an optional dependency.
      (company-mode +1))
    (setq company-tooltip-align-annotations t)
    ;; formats the buffer before saving
    ;; (add-hook 'before-save-hook 'tide-format-before-save)
    (add-hook 'typescript-mode-hook #'setup-tide-mode)
    (setq tide-format-options '(:insertSpaceAfterFunctionKeywordForAnonymousFunctions t :placeOpenBraceOnNewLineForFunctions nil :IndentStyle 2)))
#+END_SRC

Enable typescript frameworks for just typescript and prototype
#+BEGIN_SRC emacs-lisp :tangle ~/.emacs
  (setq typescript-enabled-frameworks '(typescript prototype))
#+END_SRC

Check for ts lint errors
#+BEGIN_SRC emacs-lisp :tangle ~/.emacs
  (flycheck-add-mode 'typescript-tslint 'ng2-ts-mode)
  (flycheck-add-mode 'typescript-tide 'ng2-ts-mode)
#+END_SRC

For Tide integration, use the local tsserver and fallback to the default one installed with tide. Disabled for now.
#+BEGIN_SRC emacs-lisp ~/.emacs
  (let* ((package-root (locate-dominating-file default-directory "package.json"))
	 (path (and package-root
		    (expand-file-name "node_modules/typescript/bin/tsserver"
				      (expand-file-name package-root)))))
    (when (and path (file-exists-p path))
      (make-local-variable 'tide-tsserver-executable)
      (setq tide-tsserver-executable path)))
  ;; (setq tide-tsserver-executable *tsserver*)
#+END_SRC

Add prettier support. Assumes prettier is installed globally.
#+BEGIN_SRC emacs-lisp :tangle ~/.emacs
(defun prettier-before-save ()
  "Add this to .emacs to run refmt on the current buffer when saving:
 (add-hook 'before-save-hook 'prettier-before-save)."
  (interactive)
  (when (member major-mode '(js-mode js2-mode)) (prettier)))
(add-hook 'before-save-hook 'prettier-before-save)
#+END_SRC

Add ECMA unicode glyphs that I like
#+BEGIN_SRC emacs-lisp :tangle ~/.emacs
  (add-hook 'typescript-mode-hook 'jrm/ecma-prettify-symbols)
#+END_SRC

***** Destructured Imports
Provide a way to stack imports as there is currently no option using linters
#+BEGIN_SRC emacs-lisp :tangle ~/.emacs 
  (defun jrm/stack-imports ()
    "Uses regex to stack import statements in JS/TS files."
    (interactive)
    (if (or (equal major-mode 'typescript-mode) (equal major-mode 'ng2-ts-mode))
	(jrm/stack-imports-by-regexp)))

  (defun jrm/filter-list (@predicate @sequence)
    "Return a new list such that *predicate is true on all members of *sequence.
    Lifted from http://ergoemacs.org/emacs/elisp_filter_list.html"
    (delete "e3824ad41f2ec1ed"
	    (mapcar (lambda ($x) (if (funcall @predicate $x) $x "e3824ad41f2ec1ed")) @sequence)))

  (defun isAlias (word) (if (member (downcase word) '("as")) t))

  (defun formatLineByStacking (list lastWord)
    "Stacks a list of ts/js imports via string matching"
    (when list
      (let ((word (car list))
	    (nextWord (car (cdr list))))
	(if (> (length (jrm/filter-list '(lambda (x) (string-match x word)) '("'" "\"" ";"))) 0)
	    (insert word)
	  (if (or (member (downcase word) '("import" "from" "as"))
		  (string-match "}" word)
		  (isAlias nextWord))
	      (if (isAlias nextWord)
		  (insert "  " word " ")
		(insert word " "))
	    (if (string-match "{" word) (insert word "\n")
	      (if (string-match "," word)
		  (if (isAlias lastWord)
		      (insert word "\n")
		    (insert "  " word "\n"))
		(if (member word '("" " " ","))
		    (insert "")
		  (insert "  " word ",\n")))))))
      (formatLineByStacking (cdr list) (car list))))

  (defun jrm/stack-imports-by-regexp ()
    "Stack the imports based on regexp"
    (setq origPos (point))
    (beginning-of-buffer)

    (while (re-search-forward "import[[:space:]\.].*,.*from[[:space:]\.].*;" nil t)
      (let ((line (split-string (buffer-substring-no-properties (line-beginning-position) (line-end-position)) " ")))
	(beginning-of-line)
	(kill-line)
	(formatLineByStacking line "")
	(indent-region (point-min) (point-max))))
    (goto-char origPos))

  (add-hook 'before-save-hook 'jrm/stack-imports)
#+END_SRC

By stacking imports the actual code gets pushed pretty far down in a view, so provide a way to fold them out of the view. Depends on yafolding.
#+begin_src emacs-lisp :tangle ~/.emacs
  (defcustom jrm/imports-placeholder-content "[=== Imports Hidden ===]"
    "Text to show in place of a folded block."
    :tag "Ellipsis" :type 'string :group 'jrmhideimports)

  (defface jrm/imports-placeholder-face '()
    "Face for folded blocks"
    :group 'jrmhideimports)

  (defun jrm/imports-placeholder ()
    "Return propertized ellipsis content."
    (concat " " (propertize jrm/imports-placeholder-content 'face 'jrm/imports-placeholder-face) " "))

  (defun jrm/neon-hide-imports ()
    "Hide standard imports based on regex for standard JS/TS imports of multiple modules"
    (let ((final-location (point)))
      (funcall (lambda () "Use regex to hide the imports"
		 ;; Ignore if file is under node_modules
		 (if (string-match-p (regexp-quote "/node_modules/") (file-name-directory buffer-file-name))
		     (toggle-truncate-lines)
		   (end-of-buffer)
		   (search-backward-regexp "from[[:space:]\.].*;")
		   (end-of-line)
		   (set-mark-command nil)
		   (beginning-of-buffer)
		   (let ((new-overlay (make-overlay (region-beginning) (region-end))))
		     (overlay-put new-overlay 'invisible t)
		     (overlay-put new-overlay 'intangible t)
		     (overlay-put new-overlay 'evaporate t)
		     (overlay-put new-overlay 'before-string (jrm/imports-placeholder))
		     (overlay-put new-overlay 'category "hide-js-imports"))
		   (goto-char final-location)
		   (pop-mark)
		   (toggle-truncate-lines)
		   (message "Imports hidden"))))))

  (defun jrm/has-import-overlay ()
    "Finds any matching overlays"
    (mapcar (lambda (overlay) (and (member "hide-js-imports" (overlay-properties overlay)) overlay))
	    (overlays-in (point-min) (point-max))))

  (defun jrm/neon-show-imports ()
    "Show module imports"
    (mapcar 'delete-overlay (delq nil (jrm/has-import-overlay))))

  (defun jrm/neon-toggle-imports ()
    "Show/Hide standard module import code"
    (interactive)
    (if (delq nil (jrm/has-import-overlay)) (jrm/neon-show-imports) (jrm/neon-hide-imports)))

  (global-set-key (kbd "C-x C-j C-n") 'jrm/neon-toggle-imports)
#+end_src

***** Indentation
Defining custom indentation based on project paths and setting them to functions that I can call as needed. 
#+BEGIN_SRC emacs-lisp :tangle ~/.emacs
  (defun jrm/setup-indent (n)
    (setq indent-tabs-mode nil)
    (setq-local c-basic-offset n)
    (setq-local javascript-indent-level n)
    (setq-local js-indent-level n)
    (setq-local typescript-indent-level n)
    (setq-local web-mode-markup-indent-offset 2)
    (setq-local web-mode-css-indent-offset 2)
    (setq-local web-mode-code-indent-offset n)
    (setq-local css-indent-offset 2))

  (defun jrm/neon-code-style ()
    "indent 2 spaces width"
    (interactive)
    (message "Using Neon coding style")
    (jrm/setup-indent 2))

  (defun jrm/personal-code-style ()
    "indent 4 spaces width"
    (interactive)
    (message "Using personal coding style")
    (jrm/setup-indent 4))

  (defun jrm/develop-environment ()
    "if 'neon' is in the path, set the indentation accordingly"
    (let ((proj-dir (file-name-directory (buffer-file-name))))
      (if (string-match-p "neon/" proj-dir)
	  (jrm/neon-code-style))))

  (add-hook 'typescript-mode-hook 'jrm/develop-environment)
  (add-hook 'lua-mode-hook 'jrm/develop-environment)
  (add-hook 'web-mode-hook 'jrm/develop-environment)
  (add-hook 'json-mode-hook 'jrm/neon-code-style)
#+END_SRC
**** HTML/CSS
#+BEGIN_SRC emacs-lisp :tangle ~/.emacs
  (use-package sass-mode
    :config
    (setq exec-path (cons (expand-file-name "/usr/bin/sass") exec-path))
    (add-to-list 'auto-mode-alist '("\\.scss\\'" . sass-mode)))
  (add-hook 'sgml-mode-hook (lambda () (set (make-local-variable 'sgml-basic-offset) 4) (sgml-guess-indent)))

  (use-package web-mode
    :config
    (add-to-list 'auto-mode-alist '("\\.phtml\\'" . web-mode))
    (add-to-list 'auto-mode-alist '("\\.html\\'" . web-mode))
    (add-to-list 'auto-mode-alist '("\\.tpl\\'" . web-mode))
    (add-to-list 'auto-mode-alist '("\\.mst\\'" . web-mode))
    (add-to-list 'auto-mode-alist '("\\.tpl\\.php\\'" . web-mode))
    (add-to-list 'auto-mode-alist '("\\.[agj]sp\\'" . web-mode))
    (add-to-list 'auto-mode-alist '("\\.as[cp]x\\'" . web-mode))
    (add-to-list 'auto-mode-alist '("\\.erb\\'" . web-mode))
    (add-to-list 'auto-mode-alist '("\\.mustache\\'" . web-mode))
    (add-to-list 'auto-mode-alist '("\\.djhtml\\'" . web-mode))
    (add-to-list 'auto-mode-alist '("\\.hbs\\'" . web-mode)))
#+END_SRC

**** PHP Development
#+BEGIN_SRC emacs-lisp :tangle ~/.emacs
  (use-package php-mode
    :defer
    :config
    (autoload 'php-mode "php-mode-improved" "Major mode for editing php code." t)
    (add-to-list 'auto-mode-alist '("\\.php$" . php-mode))
    (add-to-list 'auto-mode-alist '("\\.inc$" . php-mode)))
#+END_SRC

**** Additional Languages
Various modes helpful for development
#+BEGIN_SRC emacs-lisp :tangle ~/.emacs
  (use-package yaml-mode
    :defer
    :config (add-to-list 'auto-mode-alist '("\\.yml\\'" . yaml-mode)))
  (use-package restclient :defer)
  (use-package groovy-mode :defer)
  (use-package go-mode :defer)
  (use-package emmet-mode
    :defer
    :config
    (add-hook 'sgml-mode-hook 'emmet-mode)
    (add-hook 'css-mode-hook 'emmet-mode)
    (add-hook 'web-mode-hook 'emmet-mode)
    (add-hook 'sass-mode-hook 'emmet-mode))
#+END_SRC

**** Version Control
Magit for version control
#+BEGIN_SRC emacs-lisp :tangle ~/.emacs
(setenv "PATH" (concat (getenv "PATH") ":/usr/local/git/bin"))
    (setq exec-path (append exec-path '("/usr/local/git/bin")))
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle ~/.emacs
  (use-package magit
    :config
    (global-set-key (kbd "C-x g") 'magit-status)
    (add-hook 'magit-status-sections-hook 'magit-insert-stashes))
#+END_SRC

** Theme/UI
*** General Settings
#+BEGIN_SRC emacs-lisp :tangle ~/.emacs
  (use-package zerodark-theme :config (load-theme 'zerodark t))
#+END_SRC

Remove default scrollbars
#+BEGIN_SRC emacs-lisp :tangle ~/.emacs
(scroll-bar-mode -1)
#+END_SRC

Hide the default toolbars
#+BEGIN_SRC emacs-lisp :tangle ~/.emacs
  (menu-bar-mode -1)
  (tool-bar-mode -1)
#+END_SRC

I prefer to see trailing whitespace but not for every mode (e.g. org, elfeed, etc)
#+BEGIN_SRC emacs-lisp :tangle ~/.emacs
  (use-package whitespace
    :config
    (setq-default show-trailing-whitespace t)
    (defun no-trailing-whitespace ()
      (setq show-trailing-whitespace nil))
    (add-hook 'minibuffer-setup-hook              'no-trailing-whitespace)
    (add-hook 'eww-mode-hook                      'no-trailing-whitespace)
    (add-hook 'shell-mode-hook                    'no-trailing-whitespace)
    (add-hook 'mu4e:view-mode-hook                'no-trailing-whitespace)
    (add-hook 'eshell-mode-hook                   'no-trailing-whitespace)
    (add-hook 'help-mode-hook                     'no-trailing-whitespace)
    (add-hook 'term-mode-hook                     'no-trailing-whitespace)
    (add-hook 'slack-message-buffer-mode-hook     'no-trailing-whitespace)
    (add-hook 'mu4e:view-mode-hook                'no-trailing-whitespace)
    (add-hook 'calendar-mode-hook                 'no-trailing-whitespace))
#+END_SRC

Use visual line mode for text wrapping
#+BEGIN_SRC emacs-lisp :tangle ~/.emacs
  (global-visual-line-mode t)
#+END_SRC

*** Dashboard
I like a nice big splash screen and I'm partial to the meditating GNU logo.
#+BEGIN_SRC emacs-lisp :tangle ~/.emacs
  (use-package dashboard
    :config
    (dashboard-setup-startup-hook)
    (setq dashboard-startup-banner (concat *dotemacs-dir* "assets/gnu-meditate-scaled.png"))
    (setq dashboard-items '((recents  . 10)))
    (setq dashboard-banner-logo-title ""))
#+END_SRC
*** Highlight line
Helpful for finding the cursor when jumping around
#+BEGIN_SRC emacs-lisp :tangle ~/.emacs
  (global-hl-line-mode +1)
#+END_SRC

*** Modeline
Clean up modeline with diminish
#+BEGIN_SRC emacs-lisp :tangle ~/.emacs
  (use-package diminish)
#+END_SRC

Use the spaceline from spacemacs
#+begin_src emacs-lisp :tangle ~/.emacs
(use-package spaceline
  :config
  (require 'spaceline-config)
  (setq powerline-default-separator (quote wave))
  (spaceline-spacemacs-theme)
  (setq powerline-height 20)
  (set-face-attribute 'mode-line nil :box nil)
  (set-face-attribute 'mode-line-inactive nil :box nil))
#+end_src

Show spaceline icons
#+BEGIN_SRC emacs-lisp :tangle ~/.emacs
    (use-package spaceline-all-the-icons
      :after spaceline
      :config (spaceline-all-the-icons-theme))
  (custom-set-variables
   '(spaceline-all-the-icons-separator-type (quote arrow)))
#+END_SRC

*** Minibuffer
Display the current time and battery indicator
#+BEGIN_SRC emacs-lisp :tangle ~/.emacs
  (setq display-time-24hr-format t)
  (setq display-time-format "%H:%M - %d.%b.%y")
  (display-time-mode 1)
  (display-battery-mode 1)
#+END_SRC

*** Frames
Assign keyboard shortcut to more closely match the [[EXWM][exwm]] shortcuts.
#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "s-1") 'other-frame)
  (global-set-key (kbd "s-2") 'other-frame)
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle (if (string-equal system-type "darwin") "~/.emacs")
  (add-to-list 'default-frame-alist '(ns-transparent-titlebar . t))
  (add-to-list 'default-frame-alist '(ns-appearance . dark))

  ;; Autohide the top panel if necessary
  (setq ns-auto-hide-menu-bar t)
  (toggle-frame-maximized)

  (set-face-attribute 'default nil :height 120)
#+END_SRC

*** Mouse
We'll need to turn off the mouse from time to time
#+BEGIN_SRC emacs-lisp :tangle ~/.emacs
  (use-package disable-mouse :diminish disable-mouse-mode)
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle (if (string-equal system-type "darwin") "~/.emacs")
  (global-disable-mouse-mode)
#+END_SRC

Because linux runs exwm we shouldn't turn the mouse off completely.
#+BEGIN_SRC emacs-lisp :tangle (if (string-equal system-type "gnu/linux") "~/.emacs")
  (add-hook 'lisp-interaction-mode                'disable-mouse-mode)
  (add-hook 'shell-mode-hook                      'disable-mouse-mode)
  (add-hook 'org-src-mode-hook                    'disable-mouse-mode)
  (add-hook 'org-mode-hook                        'disable-mouse-mode)
  (add-hook 'javascript-mode-hook                 'disable-mouse-mode)
  (add-hook 'text-mode-hook                       'disable-mouse-mode)
  (add-hook 'web-mode-hook                        'disable-mouse-mode)
  (add-hook 'dired-mode-hook                      'disable-mouse-mode)
  (add-hook 'org-mode-hoook                       'disable-mouse-mode)
  (add-hook 'lisp-interaction-mode-hook           'disable-mouse-mode)
  (add-hook 'emacs-lisp-mode-hook                 'disable-mouse-mode)
  (add-hook 'special-mode-hook                    'disable-mouse-mode)
  (add-hook 'fundamental-mode-hook                'disable-mouse-mode)
  (add-hook 'groovy-mode-hook                     'disable-mouse-mode)
  (add-hook 'ng2-ts-mode-hook                     'disable-mouse-mode)
  (add-hook 'org-agenda-mode-hook                 'disable-mouse-mode)
  (add-hook 'eshell-mode-hook                     'disable-mouse-mode)
  (add-hook 'slack-message-buffer-mode-hook       'disable-mouse-mode)
  (add-hook 'typescript-mode-hook                 'disable-mouse-mode)
  (add-hook 'clojure-mode-hook                    'disable-mouse-mode)
  (add-hook 'repl-mode-hook                       'disable-mouse-mode)
#+END_SRC

*** Symbols
Show symbols by default
#+BEGIN_SRC emacs-lisp :tangle ~/.emacs
  (global-prettify-symbols-mode 1)
#+END_SRC

*** X Window Manager
This section is specific to running emacs as a tiling window manager desktop via EXWM. Source blocks here will if the OS is GNU/Linux.
**** General Setup

Go fullscreen and set the default font size.
#+BEGIN_SRC emacs-lisp :tangle (if (string-equal system-type "gnu/linux") "~/.emacs")
  (set-frame-parameter nil 'fullscreen 'fullboth)
  (set-face-attribute 'default nil :height 110)
#+END_SRC

 #+BEGIN_SRC shell
   #!/bin/bash

   # Let java applications know that exwm is a non-reparenting WM
   export _JAVA_AWT_WM_NONREPARENTING=1
   exec emacs
 #+END_SRC

**** EXWM
With EXWM it can act as a complete desktop environment.
#+BEGIN_SRC emacs-lisp
  (use-package exwm)
  (use-package exwm-config
    :ensure nil
    :config
    (exwm-config-default)
    (global-set-key (kbd "C-x O")  'exwm-workspace-switch-to-buffer))
#+END_SRC
***** Multiple Monitor Support

Fortunately EXWM also has support for multiple monitors.
#+BEGIN_SRC emacs-lisp
  (require 'exwm-randr)
  (setq exwm-randr-workspace-output-plist '(0 "eDP1" 1 "DP1-2" 3 "DP1-2"))
  (add-hook 'exwm-randr-screen-change-hook
	    (lambda () (start-process-shell-command "xrandr" nil "xrandr --output eDP1 --mode 2048x1152; xrandr --output eDP1 --mode 2048x1152 --right-of DP1-2 --auto")))
  (exwm-randr-enable)
#+END_SRC

Simple script for waking up second monitor after reattaching
#+BEGIN_SRC emacs-lisp
  (defun jrm/wake-second-monitor ()
      "Turns second monitor off and back on to wake it up. Helpful for exwm + X11 + multiple monitors."
    (interactive)
    (shell-command "xrandr --output DP1-2 --off && xrandr --output DP1-2 --auto"))
  (global-set-key (kbd "C-x C-j m") 'jrm/wake-second-monitor)
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle (if (string-equal system-type "gnu/linux") "~/.emacs")
  (add-hook 'dashboard-mode-hook (lambda () (shell-command "xrandr --output eDP1 --mode 2048x1152")))
#+END_SRC

**** Applications
***** DMenu Application Launcher
#+BEGIN_SRC emacs-lisp :tangle (if (string-equal system-type "gnu/linux") "~/.emacs")
  (use-package dmenu :bind ("s-SPC" . 'dmenu))
#+END_SRC
***** VLC/Multimedia
Occasionally it's helpful to be able to start, play, pause and exit vlc buffers while never having to leave your current buffer. This is particularly helpful for following along with training videos.
    #+BEGIN_SRC emacs-lisp :tangle (if (string-equal system-type "gnu/linux") "~/.emacs")
      (defvar videoBuffer "video-controller")

      (defun jrm/vlc-start-video-playlist ()
	"Start a video in VLC that can be controlled via emacs"
	(interactive)
	(let ((x (read-directory-name "Enter video directory:")))
	  (get-buffer-create videoBuffer)
	  (shell videoBuffer)
	  (process-send-string videoBuffer "cd ~/\n")
	  (process-send-string videoBuffer (concat "vlc -I rc " x "*.webm\n"))
	  (message "Now playing videos in directory %s." x)))
      (global-set-key (kbd "C-x C-j v s") 'jrm/vlc-start-video-playlist)

      (defun jrm/vlc-pause-video ()
	"Toggle pausing a running vlc stream"
	(interactive)
	(process-send-string videoBuffer "pause\n"))
      (global-set-key (kbd "C-x C-j v p") 'jrm/vlc-pause-video)

      (defun jrm/vlc-go-foward-10-video ()
	"Seek forward X seconds in a playing vlc stream"
	(interactive)
	(process-send-string videoBuffer "seek 10\n"))
      (global-set-key (kbd "C-x C-j v f") 'jrm/vlc-go-foward-10-video)

      (defun jrm/vlc-next-video ()
	"Jump to next video in playlist"
	(interactive)
	(process-send-string videoBuffer "next\n"))
      (global-set-key (kbd "C-x C-j v n") 'jrm/vlc-next-video)

      (defun jrm/vlc-last-video ()
	"Jump to previous video in playlist"
	(interactive)
	(process-send-string videoBuffer "prev\n"))
      (global-set-key (kbd "C-x C-j v l") 'jrm/vlc-last-video)

      (defun jrm/vlc-go-backward-10-video ()
	"Seek forward X seconds in a playing vlc stream"
	(interactive)
	(process-send-string videoBuffer "seek -10\n"))
      (global-set-key (kbd "C-x C-j v r") 'jrm/vlc-go-backward-10-video)

      (defun jrm/vlc-quit-video ()
	"Quit a running vlc stream"
	(interactive)
	(process-send-string videoBuffer "quit\n")
	(process-send-string videoBuffer "exit\n")
	(kill-buffer videoBuffer))
      (global-set-key (kbd "C-x C-j v q") 'jrm/vlc-quit-video)
    #+END_SRC
***** Audio Keys
#+BEGIN_SRC emacs-lisp :exports code :tangle ~/.emacs
  (defun jrm/volume-increase ()
    "Bump up the volume by 5%"
    (interactive)
    (with-temp-buffer (shell-command "/usr/bin/amixer set Master 5%+" t))
    (message "%s" (shell-command-to-string "/usr/bin/amixer get Master")))
  (global-set-key (kbd "<XF86AudioRaiseVolume>") 'jrm/volume-increase)


  (defun jrm/volume-decrease ()
    "Bump down the volume by 5%"
    (interactive)
    (with-temp-buffer (shell-command "/usr/bin/amixer set Master 5%-" t))
    (message "%s" (shell-command-to-string "/usr/bin/amixer get Master")))
  (global-set-key (kbd "<XF86AudioLowerVolume>") 'jrm/volume-decrease)

  (defun jrm/volume-mute-toggle ()
    "Toggle volume mute on/off"
    (interactive)
    (with-temp-buffer (shell-command "/usr/bin/amixer set Master toggle" t))
    (message "%s" (shell-command-to-string "/usr/bin/amixer get Master")))
  (global-set-key (kbd "<XF86AudioMute>") 'jrm/volume-mute-toggle)

#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle (if (string-equal system-type "gnu/linux") "~/.emacs")
  (defun jrm/log-volume () "Send the audio status to the message buffer"
	 (message "%s" (shell-command-to-string (concat *amixer-path* " get Master"))))

  (defun jrm/volume-increase () "Bump up the volume by 5%"
    (interactive)
    (with-temp-buffer (shell-command (concat *amixer-path* " set Master 5%+") t))
    (jrm/log-volume))
  (global-set-key (kbd "<XF86AudioRaiseVolume>") 'jrm/volume-increase)

  (defun jrm/volume-decrease () "Bump down the volume by 5%"
    (interactive)
    (with-temp-buffer (shell-command (concat *amixer-path* " set Master 5%-") t))
    (jrm/log-volume))
  (global-set-key (kbd "<XF86AudioLowerVolume>") 'jrm/volume-decrease)

  (defun jrm/volume-mute-toggle () "Toggle volume mute on/off"
    (interactive)
    (with-temp-buffer (shell-command (concat *amixer-path* " set Master toggle") t))
    (jrm/log-volume))
  (global-set-key (kbd "<XF86AudioMute>") 'jrm/volume-mute-toggle)
#+END_SRC


***** Screenshots
 I took this from Uncle Dave's config. Its a super slick screenshot function for taking both fullscreen as well as region screenshots.
 #+BEGIN_SRC emacs-lisp :tangle (if (string-equal system-type "gnu/linux") "~/.emacs")
   (defun jrm/take-screenshot ()
     "Takes a fullscreenshot of the current workspace"
     (interactive)
     (when window-system
       (cl-loop for i downfrom 3 to 1 do
		(progn
		  (message (concat (number-to-string i) "..."))
		  (sit-for 1)))
       (message "Cheese!")
       (sit-for 1)
       (start-process "screenshot" nil "import" "-window" "root"
		      (concat  *screenshot-dir* (current-time-string) ".png"))
       (message "Screenshot taken!")))
   (global-set-key (kbd "C-x C-j <C-print>") 'jrm/take-screenshot)

   (defun jrm/take-screenshot-region ()
     "Takes a screenshot of a region selected by the user"
     (interactive)
     (when window-system
       (call-process "import" nil nil nil ".newScreenshot.png")
       (call-process "convert" nil nil nil ".newScreenshot.png" "-shave" "1x1"
		     (concat (getenv "HOME") "/Pictures/" (current-time-string) ".png"))
       (call-process "rm" nil nil nil ".newScreenshot.png")))
   (global-set-key (kbd "C-x C-j <print>") 'jrm/take-screenshot-region)
 #+END_SRC
  
***** Lock screen with slock
#+BEGIN_SRC emacs-lisp
    (exwm-input-set-key (kbd "s-l") (lambda () (interactive) (start-process "" nil "/usr/bin/slock")))
  #+END_SRC

***** Interacting with GUI Applications
I find the default way (C-c C-q) of exwm sending keys like ctrl to an async buffer difficult. C-c C-c is much simpler for me.
#+BEGIN_SRC emacs-lisp :tangle
    (define-key exwm-mode-map [?\C-c ?\C-c] 'exwm-input-send-next-key)
  #+END_SRC

** Org Mode
Load some basic minor modes by default
#+BEGIN_SRC emacs-lisp :tangle ~/.emacs 
  (add-hook 'org-mode-hook 'no-trailing-whitespace)
  (add-hook 'org-mode-hook 'flyspell-mode)
#+END_SRC

*** Look and Feel
Set Org mode source block background color to dark gray so it stands out from the typical background
#+begin_src emacs-lisp :tangle ~/.emacs
(custom-set-faces '(org-block ((t (:inherit shadow :background "gray12")))))
#+end_src

Show the asterisks as bullets
#+BEGIN_SRC emacs-lisp :tangle ~/.emacs
  (use-package org-bullets :config (add-hook 'org-mode-hook (lambda () (org-bullets-mode))))
#+END_SRC

*** Navigation
Setup an easy way to jump to an org headline using org-goto =C-c C-j=
#+BEGIN_SRC elisp :tangle ~/.emacs
  (setq org-goto-interface 'outline-path-completion
	org-goto-max-level 10)

  (setq org-outline-path-complete-in-steps nil)
#+END_SRC
*** Source Blocks
When evaluating a source code block in org mode do not prompt for input, just run it.
#+BEGIN_SRC emacs-lisp :tangle ~/.emacs
  (setq org-confirm-babel-evaluate nil)
#+END_SRC

For using [[https://orgmode.org/manual/Easy-templates.html][easy templates]] in newer versions of org mode.
#+BEGIN_SRC emacs-lisp :tangle (if (not (version<= org-version "9.2")) "~/.emacs")
  (require 'org-tempo)
#+END_SRC

Set the node environment
#+BEGIN_SRC emacs-lisp :tangle ~/.emacs
  (setq org-babel-js-cmd (concat *node-dir* "node"))

#+END_SRC

**** Additional Modes
 Add some export modes for getting content out of org. Not using ~:defer~ here as I'm not sure it's helpful and adding it to ~ob-clojure~ throws a ~Wrong type argument: stringp, :defer~ error.
 #+BEGIN_SRC emacs-lisp :tangle ~/.emacs
   (use-package ox-twbs)
   (use-package ob-rust)
   (use-package ob-restclient)
   (require 'ob-clojure)
   (use-package ob-typescript :diminish typescript-mode)
 #+END_SRC

Allow asynchronous execution of org-babel src blocks so you can keep using emacs during long running scripts
#+BEGIN_SRC emacs-lisp :tangle ~/.emacs
  (use-package ob-async)
#+END_SRC

Load some languages by default
#+BEGIN_SRC emacs-lisp :tangle ~/.emacs
  (add-to-list 'org-src-lang-modes '("js" . "javascript")
	       '("php" . "php"))
  (org-babel-do-load-languages
   'org-babel-load-languages
   '((python . t)
     (js . t)
     (lisp . t)
     (clojure . t)
     (typescript . t)
     (rust . t)
     (sql . t)
     (shell . t)
     (java . t)))
#+END_SRC

I like org source blocks for typescript to use different compiler settings than what ships with ob-typescript. Not sure if there's a better way to do this, but just overwriting the function from the source with the code below using the configuration I prefer.
#+begin_src emacs-lisp :tangle ~/.emacs
  (defun org-babel-execute:typescript (body params)
    "Execute a block of Typescript code with org-babel. This function is called by `org-babel-execute-src-block'"
    (let* ((tmp-src-file (org-babel-temp-file "ts-src-" ".ts"))
	   (tmp-out-file (org-babel-temp-file "ts-src-" ".js"))
	   (cmdline (cdr (assoc :cmdline params)))
	   (cmdline (if cmdline (concat " " cmdline) ""))
	   (jsexec (if (assoc :wrap params) ""
		     (concat " ; node " (org-babel-process-file-name tmp-out-file)))))
      (with-temp-file tmp-src-file (insert body))
      (let ((results (org-babel-eval (format "tsc %s --lib 'ES7,DOM' -out %s %s %s"
					     cmdline
					     (org-babel-process-file-name tmp-out-file)
					     (org-babel-process-file-name tmp-src-file)
					     jsexec) ""))
	    (jstrans (with-temp-buffer
		       (insert-file-contents tmp-out-file)
		       (buffer-substring-no-properties (point-min) (point-max)))))
	(if (eq jsexec "") jstrans results))))
#+end_src

For org-babel's clojure backend use cider rather than the default slime
#+BEGIN_SRC emacs-lisp  ~/.emacs
  (setq org-babel-clojure-backend 'cider)
#+END_SRC

*** Org Capture
Customize org capture to my liking
#+BEGIN_SRC emacs-lisp :tangle ~/.emacs
  (global-set-key (kbd "C-c c") 'org-capture)
  (setq org-capture-templates
	'((" " "TODOs ==============================" entry (file "") "")
	  ("w" "Work Todo" entry (file "~/org/work/softwareadvice/SA.org")
	   "** TODO %? :sa:\n  %i\n  %a")
	  ("l" "Personal Todo\n" entry (file "~/org/personal/personal.org")
	   "*** TODO %? :personal:\n  %i\n  %a")
	  (" " "PROGRAMMING SNIPPETS ===============" entry (file "") "")
	  ("j" "JS Snippet" entry (file "~/org/personal/research/development/js/Javascript-snippets.org")
	   "* \n #+BEGIN_SRC js\n%?\n#+END_SRC\n\n[Date: %<%Y-%d-%m>]" :prepend t)
	  ("t" "TS Snippet\n" entry (file "~/org/personal/research/development/js/Javascript-snippets.org")
	   "* \n #+BEGIN_SRC typescript\n%?\n#+END_SRC\n\n[Date: %<%Y-%d-%m>]" :prepend t)
	  (" " "MEETINGS ===========================" entry (file "") "")
	  ("m" "Meeting\n" entry (file "~/org/work/softwareadvice/Meetings.org")
	   "** MEETING with %? :MEETING:\n  %i\n"  :clock-in t :clock-resume t)))
#+END_SRC

*** Remote Syncing
This attempts to sync an org file on save if it detects the file is in the ~*org-dir*~ directory.
#+BEGIN_SRC emacs-lisp :tangle ~/.emacs
  (defun jrm/git-auto-sync ()
    "Automatically stages, commits, pulls, and pushes the current branch's upstream settings. Commit message is current timestamp. Depends on Magit."
    (interactive)
    (magit-stage-modified)
    (magit-run-git-with-editor "commit" "-m" (format-time-string "%a %d %b %Y %H:%M:%S %Z"))
    (magit-run-git-async "pull")
    (magit-run-git-async "push"))

  (add-hook 'org-mode-hook (lambda () (add-hook 'after-save-hook 'jrm/git-auto-sync nil t)))
#+END_SRC

*** LaTex
Use xelatex for more latex options like fontspec
#+BEGIN_SRC elisp :tangle ~/.emacs
(setq org-latex-compiler "xelatex")
#+END_SRC

*** TODOs
#+BEGIN_SRC emacs-lisp :tangle ~/.emacs
  (setq org-use-fast-todo-selection t)
  (setq org-todo-keywords
	'((sequence "TODO(t)" "NEXT(n)" "|" "DONE(d)")
      (sequence "WAITING(w@/!)" "INACTIVE(i@/!)" "|" "CANCELLED(C@/!)" "MEETING")))
  ;; Custom colors for the keywords
  (setq org-todo-keyword-faces
	'(("TODO" :foreground "red" :weight bold)
      ("NEXT" :foreground "blue" :weight bold)
      ("DONE" :foreground "forest green" :weight bold)
      ("WAITING" :foreground "orange" :weight bold)
      ("INACTIVE" :foreground "magenta" :weight bold)
      ("CANCELLED" :foregroundhttp://cachestocaches.com/2016/9/my-workflow-org-agenda/ "forest green" :weight bold)
      ("MEETING" :foreground "forest green" :weight bold)))
#+END_SRC
*** Org Export
#+BEGIN_SRC emacs-lisp :tangle ~/.emacs
  (custom-set-variables
   '(org-export-backends '(ascii html icalendar latex md odt)))
#+END_SRC
*** Markdown
#+BEGIN_SRC emacs-lisp
  (use-package grip-mode
    :ensure-system-package (grip . "pip install grip"))
#+END_SRC
** Shells
By default just use bash for all shells
#+BEGIN_SRC emacs-lisp :tangle ~/.emacs
  (defvar my-term-shell "/bin/bash")
  (defadvice ansi-term (before force-bash)
    (interactive (list my-term-shell)))
  (ad-activate 'ansi-term)
#+END_SRC

Make shells interactive (i.e. M-!, or source blocks in org)
#+BEGIN_SRC emacs-lisp :tangle ~/.emacs
  (setq shell-command-switch "-ic")
#+END_SRC

Fixes emacs and osx path issues.
#+BEGIN_SRC emacs-lisp :tangle (if (string-equal system-type "darwin") "~/.emacs")
  (use-package exec-path-from-shell
    :config
    (when (memq window-system '(mac ns x))
      (exec-path-from-shell-initialize)))
#+END_SRC

** Consuming Content
*** Elfeed
Many thanks to [[http://pragmaticemacs.com/emacs/read-your-rss-feeds-in-emacs-with-elfeed/][pragmatic emacs' post]] for guidance on this setup.
#+BEGIN_SRC emacs-lisp :tangle ~/.emacs
  (use-package elfeed-org
    :config (elfeed-org) (setq rmh-elfeed-org-files (list (concat *org-dir* "personal/elfeed.org"))))

  (defun jrm/elfeed-show-all ()
    (interactive)
    (bookmark-maybe-load-default-file)
    (bookmark-jump "elfeed-all"))
  (defun jrm/elfeed-show-development ()
    (interactive)
    (bookmark-maybe-load-default-file)
    (bookmark-jump "elfeed-development"))
  (defun jrm/elfeed-show-news ()
    (interactive)
    (bookmark-maybe-load-default-file)
    (bookmark-jump "elfeed-news"))
  (defun jrm/elfeed-show-emacs ()
    (interactive)
    (bookmark-maybe-load-default-file)
    (bookmark-jump "elfeed-emacs"))

  (defun jrm/elfeed-load-db-and-open ()
    "Wrapper to load the elfeed db from disk before opening"
    (interactive)
    (elfeed-db-load)
    (elfeed)
    (elfeed-search-update--force))

  (defun jrm/elfeed-save-db-and-bury ()
    "Wrapper to save the elfeed db to disk before burying buffer"
    (interactive)
    (elfeed-db-save)
    (quit-window))

  (use-package elfeed
    :defer
    :bind (:map elfeed-search-mode-map
		("A" . jrm/elfeed-show-all)
		("E" . jrm/elfeed-show-emacs)
		("D" . jrm/elfeed-show-development)
		("N" . jrm/elfeed-show-news)
		("q" . jrm/elfeed-save-db-and-bury)))

  (global-set-key (kbd "C-x e") 'jrm/elfeed-load-db-and-open)
#+END_SRC

Sometimes it's helpful to hide images for certain posts.
#+BEGIN_SRC emacs-lisp :tangle ~/.emacs
  (defun jrm/elfeed-show-hide-images ()
    (interactive)
    (let ((shr-inhibit-images t))
      (elfeed-show-refresh)))
  (global-set-key (kbd "C-x C-j e") 'jrm/elfeed-show-hide-images)
#+END_SRC

** Helpful Utility Functions
Most of the functions in this section are bound to ~C-x C-j~ prefix key.
*** Copy Entire Buffer easily
#+BEGIN_SRC emacs-lisp :tangle ~/.emacs
  (defun jrm/copy-all ()
    "Copy the current buffer without loosing your place"
    (interactive)
    (let ((original-position (point)))
      (mark-whole-buffer)
      (kill-ring-save 0 0 t)
      (goto-char original-position)
      (message "Buffer contents yanked.")))
  (global-set-key (kbd "C-x C-j C-c") 'jrm/copy-all)
#+END_SRC

*** Quickly Change Font Sizes
I find myself need specific font sizes for different scenarios, i.e. projecting, screen-sharing on conference calls, etc. So, binding these to a quick way to toggle through them. 

/Note: there might be a better way to handle this but things like M-+/M-- won't zoom things like line numbers, etc./
#+BEGIN_SRC emacs-lisp :tangle ~/.emacs
  (defvar jrm/screens-alist '((?1 "small" (lambda () (set-face-attribute 'default nil :height 110) 'default))
			      (?2 "medium" (lambda () (set-face-attribute 'default nil :height 120) 'proj))
			      (?3 "large" (lambda () (set-face-attribute 'default nil :height 140) 'proj))
			      (?4 "xtra-large" (lambda () (set-face-attribute 'default nil :height 160) 'projLg)))
    "List that associates number letters to descriptions and actions.")
  (defun jrm/adjust-font-size ()
    "Lets the user choose the the font size and takes the corresponding action.
  Returns whatever the action returns."
    (interactive)
    (let ((choice (read-char-choice
		   (mapconcat (lambda (item) (format "%c: %s" (car item) (cadr item)))
			      jrm/screens-alist "; ")
		   (mapcar #'car jrm/screens-alist))))
      (funcall (nth 2 (assoc choice jrm/screens-alist)))))
  (global-set-key (kbd "C-x C-j p")  'jrm/adjust-font-size)
#+END_SRC

*** Copy current file path
Lifted from (http://ergoemacs.org/emacs/emacs_copy_file_path.html)
#+BEGIN_SRC emacs-lisp :tangle ~/.emacs
  (defun jrm/copy-file-path (&optional *dir-path-only-p)
    "Copy the current buffer's file path or dired path to `kill-ring'.
  Result is full path."
    (interactive "P")
    (let ((-fpath
	   (if (equal major-mode 'dired-mode)
	       (expand-file-name default-directory)
	     (if (buffer-file-name)
		 (buffer-file-name)
	       (user-error "Current buffer is not associated with a file.")))))
      (kill-new
       (if *dir-path-only-p
	   (progn
	     (message "Directory path copied: 「%s」" (file-name-directory -fpath))
	     (file-name-directory -fpath))
	 (progn (message "File path copied: 「%s」" -fpath) -fpath )))))
#+END_SRC

*** Basic debugging
A bit of helpful debugging for a few modes
#+BEGIN_SRC emacs-lisp :tangle ~/.emacs
  (defun jrm/insert-debug-log ()
    "Inserts logging based on mode"
    (interactive)
    (when (or (equal major-mode 'js-mode) (equal major-mode 'js2-mode) (equal major-mode 'typescript-mode) (equal major-mode 'ng2-ts-mode))
      (insert "console.log(\"\");")
      (backward-char 3))
    (when (equal major-mode 'clojure-mode)
      (insert "(println (format \"%s\" ))")
      (backward-char 2))
    (when (equal major-mode 'emacs-lisp-mode)
      (insert "(message (format \"%s\" ))")
      (backward-char 2)))

  (global-set-key (kbd "C-x C-j d") 'jrm/insert-debug-log)
#+END_SRC


** Final Pieces
*** Remap Key sequences
#+BEGIN_SRC emacs-lisp :tangle ~/.emacs
  (global-set-key (kbd "S-u") '(lambda () (interactive) (revert-buffer t (not (buffer-modified-p)) t)))
#+END_SRC

*** Last Line
#+BEGIN_SRC emacs-lisp :tangle ~/.emacs
  (provide '.emacs)
#+END_SRC



