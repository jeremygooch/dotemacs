* My Personal Config
** Installation
This is my personal emacs configuration written in a literate-programming style. To generate the config tangle this file with org-babel-tangle (~C-c C-v t~).

Some of the code blocks pertain to the OS and will be tangled automatically. There are several blocks for Linux that pertain to running emacs as a window manager. These blocks can be found in [[X Window Manager][this section]].

*** Global Configs
#+NAME: config
#+BEGIN_SRC emacs-lisp :tangle ~/.emacs
  (defvar *home-dir*              (getenv "HOME"))
  (defvar *dotemacs-dir*          (concat *home-dir* "/src/dotemacs/"))
  (defvar *node-dir*              (concat *home-dir* "/.nvm/versions/node/v10.8.0/bin/"))
  (defvar *org-dir*               (concat *home-dir* "/org/"))

  (defvar *tsserver*              (concat *home-dir* "/src/TypeScript/lib/tsserver.js"))
#+END_SRC

*** Load Utilities
    #+begin_src emacs-lisp :tangle ~/.emacs
      (load "~/.emacs.d/jrm-util.el")
    #+end_src
* Configuration
#+TOC: headlines 2

** Initialization
Load the config if it exists, otherwise load the sample

*** Package Sources
Setting up basic repositories and [[https://github.com/jwiegley/use-package][use-package]].
#+BEGIN_SRC emacs-lisp  :tangle ~/.emacs
  (package-initialize)
  (require 'package)
  (setq package-enable-at-startup nil)
  (setq package-archives '(
			   ("marmalade"  . "http://marmalade-repo.org/packages/")
			   ("melpa-stable" . "http://stable.melpa.org/packages/")
			   ("gnu" . "http://elpa.gnu.org/packages/")
			   ;; ("org" . "https://orgmode.org/elpa/")
			   ("melpa" . "https://melpa.org/packages/")))
#+END_SRC

*** use-package Setup
#+BEGIN_SRC emacs-lisp :tangle ~/.emacs
  (unless (package-installed-p 'use-package)
    (package-refresh-contents)
    (package-install 'use-package))

  (require 'use-package-ensure)
  (setq use-package-always-ensure t)
#+END_SRC

Allow use-package to install missing system packages
#+BEGIN_SRC emacs-lisp
(use-package use-package-ensure-system-package
  :ensure t)
#+END_SRC

*** Personal Information
For the sake of completeness, configure name and email address
#+BEGIN_SRC emacs-lisp  :tangle ~/.emacs
  (setq user-full-name "Jeremy Gooch"
        user-mail-address "jeremy.gooch@gmail.com")
#+END_SRC

Setup a prefix for custom commands.
#+BEGIN_SRC emacs-lisp :tangle ~/.emacs
  (progn (define-prefix-command 'jrm-key-map))
  (global-set-key (kbd "C-x C-j") jrm-key-map)
#+END_SRC

** General Configuration
*** Basic Emacs Settings Preferences
I prefer emacs to just ask y/n not yes/no
 #+BEGIN_SRC emacs-lisp :tangle ~/.emacs
   (fset 'yes-or-no-p 'y-or-n-p)
 #+END_SRC

When killing a buffer always pick the current buffer by default
#+BEGIN_SRC emacs-lisp  :tangle ~/.emacs
  (defun kill-current-buffer ()
    "Kills the current buffer."
    (interactive)
    (kill-buffer (current-buffer)))
  (global-set-key (kbd "C-x k") 'kill-current-buffer)
#+END_SRC

Prevent async shell command buffers from popping-up:
#+BEGIN_SRC emacs-lisp :tangle ~/.emacs
  (add-to-list 'display-buffer-alist
    '("\\*Async Shell Command\\*.*" display-buffer-no-window))
#+END_SRC

Fix emacs' regex
#+BEGIN_SRC emacs-lisp :tangle ~/.emacs
  (setq-default pcre-mode t)
#+END_SRC

Use aspell for Mac (aspell can be installed with brew)
#+BEGIN_SRC emacs-lisp :tangle (if (string-equal system-type "darwin") "~/.emacs")
(setq ispell-program-name "/usr/local/bin/aspell")
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle (if (string-equal system-type "darwin") "~/.emacs")
  (setq exec-path (append exec-path '("/usr/local/bin")))
  (use-package exec-path-from-shell
    :init
    (exec-path-from-shell-initialize))
#+END_SRC

Silence alarms
#+BEGIN_SRC emacs-lisp :tangle ~/.emacs
  (setq ring-bell-function 'ignore)
#+END_SRC

*** Dired
Some basic Dired setup
#+BEGIN_SRC emacs-lisp :tangle ~/.emacs
  (global-auto-revert-mode 1)
  (setq global-auto-revert-non-file-buffers t)
  (setq auto-revert-verbose nil)
  (setq dired-listing-switches "-alh")
#+END_SRC

It's nice to be able to tab through directories in dired, and I'm a sucker for eye candy with icons
#+BEGIN_SRC emacs-lisp :tangle ~/.emacs
  (defun jrm/dired-subtree-toggle-and-refresh ()
    "Calls dired toggle and refreshes the buffer."
    (interactive)
    (dired-subtree-toggle)
    (revert-buffer))

  (use-package dired-subtree
    :after dired
    :config
    (bind-key "<tab>" #'jrm/dired-subtree-toggle-and-refresh dired-mode-map)
    (bind-key "<backtab>" #'dired-subtree-cycle dired-mode-map))

  (use-package all-the-icons-dired)
  (add-hook 'dired-mode-hook 'all-the-icons-dired-mode)
#+END_SRC

Allow uncompressing zip files
#+begin_src emacs-lisp :tangle ~/.emacs
  (eval-after-load "dired-aux"
     '(add-to-list 'dired-compress-file-suffixes 
		   '("\\.zip\\'" ".zip" "unzip")))
#+end_src

*** Tramp
#+BEGIN_SRC emacs-lisp :tangle ~/.emacs
  (use-package tramp :config (setq tramp-default-method "scp"))
#+END_SRC

*** RipGrep
Use ripgrep by default
#+BEGIN_SRC emacs-lisp :tangle ~/.emacs
  (use-package rg
    :config
    (rg-define-search work
      :flags ("--hidden -g '!e2e/'")))
#+END_SRC

Enable searching for files in .gitignore, for work specific projects
#+begin_src emacs-lisp :tangle (if (string-equal system-type "darwin") "~/.emacs")
  (setq rg-command-line-flags '("--no-ignore"))
#+end_src


*** IBuffer
#+BEGIN_SRC emacs-lisp  :tangle ~/.emacs
	(global-set-key (kbd "C-x C-b") 'ibuffer)
	(setq ibuffer-saved-filter-groups
	(quote (("default"
		 ("dired" (mode . dired-mode))
		 ("org" (mode . org-mode))
		 ("shell" (mode . shell-mode))
		 ("git" (name . "^magit\*"))
		 ("Slack" (or (mode . slack-mode)
						(name . "^\\*Slack.*$")))
		 ("email" (name . "^\\*mu4e-.*\\*$"))
		 ("ecmascript" (or (mode . javascript-mode)
					 (name . "^.*.js$")
					 (name . "^.*.ts")
					 (name . "^.*.json$")))
		 ("markup" (or (mode . web-mode)
						 (name . "^.*.tpl")
						 (name . "^.*.mst")
						 (name . "^.*.html")))
		 ("images" (name . "^.*png$"))
		 ("process" (or (mode . grep-mode)
				(name . "^\\*tramp*$")))
		 ("emacs" (or (name . "^\\*scratch\\*$")
						(name . "^\\*Messages\\*$")
						(name . "^\\*eww\\*$")
						(name . "^\\*GNU Emacs\\*$")))))))
	(add-hook 'ibuffer-mode-hook (lambda () (ibuffer-switch-to-saved-filter-groups "default")))
#+END_SRC

*** GPG Pinentry
Instead of using the display's popup, prompt for gpg creds in the minibuffer
#+BEGIN_SRC emacs-lisp  :tangle ~/.emacs
  (setq epa-pinentry-mode 'loopback)
#+END_SRC

*** Company mode
#+BEGIN_SRC emacs-lisp  :tangle ~/.emacs
  (use-package company :diminish company-mode
    :init (add-hook 'after-init-hook 'global-company-mode))
#+END_SRC

Company-mode with icons
#+BEGIN_SRC emacs-lisp :tangle ~/.emacs
(use-package company-box
  :hook (company-mode . company-box-mode)
  :diminish company-box-mode)
(setq company-idle-delay 0.2)
#+END_SRC

** Introspection
*** Ivy/Counsel/Swiper
Generic auto-complete with Ivy which 
 #+BEGIN_SRC emacs-lisp  :tangle ~/.emacs
   (use-package ivy :demand
     :diminish ivy-mode
     :config
     (setq ivy-use-virtual-buffers t
	   ivy-count-format "%d/%d ")
     (global-set-key (kbd "C-x b") 'ivy-switch-buffer))
   (ivy-mode 1)
   (setq ivy-use-selectable-prompt t)

   (use-package ivy-prescient
     :config (ivy-prescient-mode))
 #+END_SRC

 Ivy enhanced search (swiper) and common Emacs meta commands (counsel)
 #+BEGIN_SRC emacs-lisp  :tangle ~/.emacs
   (use-package counsel
     :config
     (global-set-key (kbd "M-x") 'counsel-M-x)
     (global-set-key (kbd "C-M-SPC") 'counsel-git))

   (use-package swiper
     :config
     (global-set-key (kbd "C-s") 'swiper-isearch))
 #+END_SRC
**** Hack-around for poorly shared plugins
     #+begin_src emacs-lisp :tangle (if (string-equal system-type "darwin") "~/.emacs")
       (setq counsel-find-file-ignore-regexp "\\(aurelia_project\\|node_modules\\|dist\\|coverage-jest\\)")
       (defun jrm/counsel-find-all-hack ()
	 "Hackaround for poorly shared plugins"
	 (interactive)
	 (counsel-file-jump "" (vc-root-dir)))
       (global-set-key (kbd "C-M-SPC") 'jrm/counsel-find-all-hack)

       (defun ignored-file-background ()
	 (interactive)
	 (setq buffer-face-mode-face `(:background "#342828"))
	 (buffer-face-mode 1))
       (define-minor-mode ignored-file-mode
	 "Mode for files that are ignored in VC"
	 :lighter " IGNORED-FILE")
       (add-hook 'ignored-file-mode-hook 'ignored-file-background)
       (defun jrm/set-ignored-mode () ""
	      (let ((ignored (shell-command-to-string (concat "git check-ignore " (buffer-file-name)))))
		(if (not (string-empty-p ignored))
		    (ignored-file-mode))))

       (add-hook 'js2-mode-hook 'jrm/set-ignored-mode)
       (add-hook 'ng2-ts-mode-hook 'jrm/set-ignored-mode)
       (add-hook 'ng2-html-mode-hook 'jrm/set-ignored-mode)
       (add-hook 'css-mode-hook 'jrm/set-ignored-mode)
       (add-hook 'scss-mode-hook 'jrm/set-ignored-mode)
       (add-hook 'web-mode-hook 'jrm/set-ignored-mode)
     #+end_src

*** Which key
Some quick help for when I get stuck in the middle of a command
#+BEGIN_SRC emacs-lisp :tangle ~/.emacs
  (use-package which-key :config (which-key-mode))
#+END_SRC

** File Editing/Navigation
*** General Settings
 Keep temporary and backup buffers out of current directory like a civilized human being.
 #+BEGIN_SRC emacs-lisp :tangle ~/.emacs
   (custom-set-variables
    '(auto-save-file-name-transforms '((".*" "~/.emacs.d/autosaves/\\1" t)))
    '(backup-directory-alist '((".*" . "~/.emacs.d/backups/")))
    '(delete-old-versions t))

   (make-directory "~/.emacs.d/autosaves/" t)
   (setq create-lockfiles nil)
 #+END_SRC

 Disable the narrow-to-region message
 #+BEGIN_SRC emacs-lisp :tangle ~/.emacs
   (put 'narrow-to-region 'disabled nil)
 #+END_SRC

Replace region with next keystroke.
#+BEGIN_SRC emacs-lisp :tangle ~/.emacs
  (delete-selection-mode 1)
#+END_SRC

Disable bidirectional editing for performance issues when opening large files.
#+begin_src emacs-lisp :tangle ~/.emacs
  (setq bidi-paragraph-direction 'left-to-right)
#+end_src

*** Yasnippet
    #+begin_src emacs-lisp :tangle ~/.emacs
      (use-package yasnippet)
      (use-package yasnippet-snippets
	:init (setq yas-snippet-dirs
	    '("~/.emacs.d/snippets"
	      "~/src/dotemacs/snippets"))
	:config (yas-global-mode))
    #+end_src
*** In-file Navigation
Easier paragraph jumping
 #+BEGIN_SRC emacs-lisp :tangle ~/.emacs
   (global-set-key (kbd "M-p") 'backward-paragraph)
   (global-set-key (kbd "M-n") 'forward-paragraph)
 #+END_SRC

Avy is great for speed-of-thought navigation
 #+BEGIN_SRC emacs-lisp :tangle ~/.emacs
   (use-package avy)
   (global-set-key (kbd "M-s") 'avy-goto-char-timer)
   (global-set-key (kbd "C-c SPC") 'avy-goto-line)
 #+END_SRC

Turn on linum mode for almost everything.
#+BEGIN_SRC emacs-lisp :tangle ~/.emacs
  (global-set-key (kbd "C-c l l") 'display-line-numbers-mode)
#+END_SRC

Adjust the local mark ring pop key sequence, so after pressing `C-u C-SPC`, you can just press `C-SPC` to keep jumping.
#+BEGIN_SRC emacs-lisp :tangle ~/.emacs
  (setq set-mark-command-repeat-pop t)
#+END_SRC

*** Programming
For obvious reasons it is helpful to be able to toggle formatting the buffer before saving
#+begin_src emacs-lisp :tangle ~/.emacs
  (defun jrm/tslint-before-save ()
    "Use tide and tslint to fix buffer after saving"
    (if (or (equal major-mode 'typescript-mode) (equal major-mode 'ng2-ts-mode) (equal major-mode 'js2-mode))
	(progn
	  (async-shell-command (concat (vc-root-dir) "node_modules/eslint/bin/eslint.js --fix " (expand-file-name buffer-file-name))))))

  (defun jrm/toggle-lint-before-save ()
    "Toggle running the tslint command before saving a buffer"
    (interactive)
    (if (string-match-p (regexp-quote "tslint-before-save") (format "%s" (symbol-value 'before-save-hook)))
	(progn
	  (remove-hook 'before-save-hook 'jrm/tslint-before-save)
	  (message "Removed Lint Before Save Hook"))
      (progn
	(add-hook 'before-save-hook 'jrm/tslint-before-save)
	(message "Added Lint Before Save Hook"))))
#+end_src

**** LSP
#+BEGIN_SRC emacs-lisp :tangle ~/.emacs
      (use-package lsp-mode
	      :hook (ng2-ts-mode . lsp)
	      :hook (typescript-mode . lsp)
	      :hook (javascript-mode . lsp)
	      :hook (js2-mode . lsp)
	      :hook (html-mode . lsp)
	      :hook (scss-mode . lsp)
	      :hook (sass-mode . lsp)
	      :hook (css-mode . lsp)
	      :hook (web-mode . lsp)
	      :hook (clojure-mode . lsp)
	      :commands lsp
	      :bind (("M-." . lsp-find-definition))
	      :bind (("M-n" . forward-paragraph))
	      :bind (("M-p" . backward-paragraph))
	      :config
	      (dolist (m '(clojure-mode
			   clojurec-mode
			   clojurescript-mode
			   clojurex-mode))
		(add-to-list 'lsp-language-id-configuration `(,m . "clojure"))
		(setq company-lsp-cache-candidates t)))
      ;; optionally
      (use-package lsp-ui :commands lsp-ui-mode)
      (use-package company-lsp :commands company-lsp)
      (push 'company-lsp company-backends)
      (use-package helm-lsp :commands helm-lsp-workspace-symbol)
      (use-package lsp-treemacs :commands lsp-treemacs-errors-list)
      ;; optionally if you want to use debugger
      (use-package dap-mode)
    ;; (global-set-key (kbd "M-p") 'backward-paragraph)
    (define-key lsp-signature-mode-map (kbd "M-p") 'backward-paragraph)
    (define-key lsp-signature-mode-map (kbd "M-n") 'forward-paragraph)
  ;; (global-set-key (kbd "M-n") 'forward-paragraph)

  #+END_SRC

Lsp Mode Performance adjustments (see https://github.com/emacs-lsp/lsp-mode#performance).
#+BEGIN_SRC emacs-lisp
  (setq gc-cons-threshold 100000000)
  (setq read-process-output-max (* 1024 1024))
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle ~/.emacs
  (setq lsp-html-server-command (quote
				 ((concat *node-dir* "html-languageserver") "--stdio")))

  (setq lsp-clients-angular-language-server-command (quote
      ("node" "/home/jeremy/.nvm/versions/node/v10.8.0/lib/node_modules/@angular/language-server" "--ngProbeLocations" "/home/jeremy/.nvm/versions/node/v10.8.0/lib/node_modules" "--tsProbeLocations" "/usr/lib/node_modules" "--stdio")))
#+END_SRC

Dap is used for debugging in browser(s). More information at: https://emacs-lsp.github.io/lsp-mode/tutorials/reactjs-tutorial/
#+begin_src emacs-lisp :tangle ~/.emacs
(require 'dap-chrome)
#+end_src

**** Lisps
Paredit for maintaining sanity while working with lisp
#+BEGIN_SRC emacs-lisp :tangle ~/.emacs
  (defun paredit-enable-modes () (add-hook 'emacs-lisp-mode-hook 'paredit-mode))

  (use-package paredit :config (paredit-enable-modes))
#+END_SRC

Some general settings for lisp dialects (elisp, clojure, etc).
#+BEGIN_SRC emacs-lisp :tangle ~/.emacs
  (autoload 'enable-paredit-mode "paredit" "Turn on pseudo-structural editing of Lisp code." t)
  (add-hook 'emacs-lisp-mode-hook       #'enable-paredit-mode)
  (add-hook 'eval-expression-minibuffer-setup-hook #'enable-paredit-mode)
  (add-hook 'ielm-mode-hook             #'enable-paredit-mode)
  (add-hook 'lisp-mode-hook             #'enable-paredit-mode)
  (add-hook 'lisp-interaction-mode-hook #'enable-paredit-mode)
  (add-hook 'scheme-mode-hook           #'enable-paredit-mode)
  (add-hook 'clojure-mode-hook          #'enable-paredit-mode)
#+End_SRC

***** elisp
Make evaluating elisp buffers even quicker
#+BEGIN_SRC emacs-lisp :tangle ~/.emacs
  (global-set-key (kbd "C-c C-e")  'eval-buffer)
#+END_SRC
***** Clojure Development
Clojure with Cider for interactive Clojure development
#+BEGIN_SRC emacs-lisp
  (use-package clojure-mode
    :defer
    :config
    (add-to-list 'auto-mode-alist '("\\.edn$" . clojure-mode))
    (add-to-list 'auto-mode-alist '("\\.boot$" . clojure-mode))
    (add-to-list 'auto-mode-alist '("\\.cljs.*$" . clojure-mode))
    (add-to-list 'auto-mode-alist '("lein-env" . enh-ruby-mode)))

  (use-package eldoc :diminish eldoc-mode)

  (use-package cider
    :defer
    :config
    (add-hook 'cider-repl-mode-hook #'eldoc-mode)
    (setq cider-repl-pop-to-buffer-on-connect t) ;; go to the repl when done connecting
    (setq cider-show-error-buffer t)
    (setq cider-auto-select-error-buffer t)) ;; jump to error message
#+END_SRC

****** Clojure/Quil Workflow Customization
A popup HSV color picker is helpful for quick prototyping/sketching
#+BEGIN_SRC emacs-lisp
  (defun convert-range-360 (val)
    "Converts a value from a 0-1 range to 0-360 range. Used for calculating hue."
    (* (/ (- val 0) (- 1 0)) (+ (- 360 0) 0)))

  (defun jrm/insert-color-hsb ()
    "Select a color and insert its hue/saturation/brightness[lumenosity] format."
    (interactive "*")
    (let ((buf (current-buffer)))
      (custom-set-variables '(list-colors-sort (quote hsv)))
      (list-colors-display
       nil nil `(lambda (name)
		  (interactive)
		  (quit-window)
		  (with-current-buffer ,buf
		    (setq hsb (apply 'color-rgb-to-hsl (color-name-to-rgb name)))
		    (setq hue (convert-range-360 (nth 0 hsb)))
		    (setq sat (* 100 (nth 1 hsb)))
		    (insert (format "%s" hue 100) " " (format "%s" sat) " " (format "%s" 100.0)))))))
  (global-set-key (kbd "C-x C-j H")  'jrm/insert-color-hsb)
#+END_SRC

**** ECMAScript
Tern is a require package and can be installed with ~sudo npm install -g tern~

***** General Settings
Some basic code folding
#+BEGIN_SRC emacs-lisp :tangle ~/.emacs
  (use-package yafolding
    :hook ((ng2-ts-mode . yafolding-mode)
	   (js-mode . yafolding-mode)
	   (fundamental-mode . yafolding-mode)))
#+END_SRC

Use js2 mode rather than the built in javascript mode.
#+BEGIN_SRC emacs-lisp :tangle ~/.emacs
  (use-package js2-mode
    :defer
    :init
    (add-to-list 'auto-mode-alist '("\\.js\\'" . js2-mode))
    (add-to-list 'auto-mode-alist '("\\.mjs\\'" . js2-mode)))

  (bind-keys*
   ("M-." . lsp-find-definition))
#+END_SRC

Setup ECMA unicode glyphs
#+BEGIN_SRC emacs-lisp :tangle ~/.emacs
  (defun jrm/ecma-prettify-symbols ()
    "Adds common ECMA symobls to prettify-symbols-alist."
    (push '(">=" . ?≥) prettify-symbols-alist)
    (push '("=>" . ?⇒) prettify-symbols-alist)
    (push '("<=" . ?≤) prettify-symbols-alist)
    (push '("===" . ?≡) prettify-symbols-alist)
    (push '("!=" . ?≠) prettify-symbols-alist)
    (push '("!==" . ?≢) prettify-symbols-alist)
    (push '("&&" . ?∧) prettify-symbols-alist)
    (prettify-symbols-mode))

  (add-hook 'js2-mode-hook 'jrm/ecma-prettify-symbols)
  (add-hook 'js-mode-hook 'jrm/ecma-prettify-symbols)
#+END_SRC

Web Beautify for unminifying assets
#+BEGIN_SRC emacs-lisp :tangle ~/.emacs
  (use-package web-beautify)
#+END_SRC

***** Angular/React/TS Development
#+BEGIN_SRC emacs-lisp :tangle ~/.emacs
  ;; (setq exec-path (append exec-path '(*node-dir*)))
  (custom-set-variables
   '(flycheck-typescript-tslint-executable "/home/jeremy/src/cb-consume-ui/node_modules/tslint/bin/tslint"))
  (use-package ng2-mode)
  (use-package flycheck :diminish flycheck-mode)

#+END_SRC

Enable typescript frameworks for just typescript and prototype
#+BEGIN_SRC emacs-lisp :tangle ~/.emacs
  (setq typescript-enabled-frameworks '(typescript prototype))
#+END_SRC

Check for ts lint errors
#+BEGIN_SRC emacs-lisp :tangle ~/.emacs
  (flycheck-add-mode 'typescript-tslint 'ng2-ts-mode)
#+END_SRC

Rjsx for JSX
#+begin_src emacs-lisp :tangle ~/.emacs
  (use-package rjsx-mode
    :config (add-to-list 'auto-mode-alist '("src/elfeed-web-react/.*\\.js\\'" . rjsx-mode)))
#+end_src

Add prettier support. Assumes prettier is installed globally.
#+BEGIN_SRC emacs-lisp :tangle ~/.emacs
(defun prettier-before-save ()
  "Add this to .emacs to run refmt on the current buffer when saving:
 (add-hook 'before-save-hook 'prettier-before-save)."
  (interactive)
  (when (member major-mode '(js-mode js2-mode)) (prettier)))
(add-hook 'before-save-hook 'prettier-before-save)
#+END_SRC

Add ECMA unicode glyphs that I like
#+BEGIN_SRC emacs-lisp :tangle ~/.emacs
  (add-hook 'typescript-mode-hook 'jrm/ecma-prettify-symbols)
#+END_SRC

***** Indentation
Defining custom indentation based on project paths and setting them to functions that I can call as needed. 
#+begin_src emacs-lisp :tangle ~/.emacs
  (defun jrm/setup-indent (n)
    (setq indent-tabs-mode nil)
    (setq-local c-basic-offset n)
    (setq-local javascript-indent-level n)
    (setq-local js-indent-level n)
    (setq-local typescript-indent-level n)
    (setq-local web-mode-markup-indent-offset n)
    (setq-local web-mode-css-indent-offset n)
    (setq-local web-mode-code-indent-offset n)
    (setq-local sass-indent-offset n)
    (setq-local css-indent-offset n))

  (defun jrm/two-space-code-style ()
    "indent 2 spaces width"
    (interactive)
    (message "Using 2 spaces coding style")
    (jrm/setup-indent 2))

  (defun jrm/four-space-code-style ()
    "indent 4 spaces width"
    (interactive)
    (message "Using 4 spaces coding style")
    (jrm/setup-indent 4))

  ;; (defun jrm/develop-environment ()
  ;;   "if 'neon' is in the path, set the indentation accordingly"
  ;;   (let ((proj-dir (file-name-directory (buffer-file-name))))
  ;;     (if (string-match-p "neon/" proj-dir)
  ;; 	  (jrm/neon-code-style))))
#+end_src

#+begin_src emacs-lisp :tangle (if (string-equal system-type "darwin") "~/.emacs")
  (add-hook 'typescript-mode-hook 'jrm/four-space-code-style)
  (add-hook 'lua-mode-hook 'jrm/four-space-code-style)
  (add-hook 'web-mode-hook 'jrm/four-space-code-style)
  (add-hook 'js-mode-hook 'jrm/four-space-code-style)
  (add-hook 'js2-mode-hook 'jrm/four-space-code-style)
  (add-hook 'sass-mode-hook 'jrm/four-space-code-style)
  (add-hook 'scss-mode-hook 'jrm/four-space-code-style)
#+end_src

#+begin_src emacs-lisp :tangle (if (not (string-equal system-type "darwin")) "~/.emacs")
  (add-hook 'typescript-mode-hook 'jrm/two-space-code-style)
  (add-hook 'lua-mode-hook 'jrm/two-space-code-style)
  (add-hook 'web-mode-hook 'jrm/two-space-code-style)
  (add-hook 'json-mode-hook 'jrm/two-space-code-style)
  (add-hook 'js2-mode-hook 'jrm/two-space-code-style)
  ;; (add-hook 'typescript-mode-hook 'jrm/develop-environment)
  ;; (add-hook 'lua-mode-hook 'jrm/develop-environment)
  ;; (add-hook 'web-mode-hook 'jrm/develop-environment)
  ;; (add-hook 'json-mode-hook 'jrm/neon-code-style)
#+END_SRC
**** HTML/CSS
#+BEGIN_SRC emacs-lisp :tangle ~/.emacs
  (use-package sass-mode
    :config
    (setq exec-path (cons (expand-file-name (concat *node-dir* "sass")) exec-path))
    (add-to-list 'auto-mode-alist '("\\.scss\\'" . scss-mode)))

  (use-package web-mode
    :config
    (add-to-list 'auto-mode-alist '("\\.phtml\\'" . web-mode))
    (add-to-list 'auto-mode-alist '("\\.html\\'" . web-mode))
    (add-to-list 'auto-mode-alist '("\\.tpl\\'" . web-mode))
    (add-to-list 'auto-mode-alist '("\\.mst\\'" . web-mode))
    (add-to-list 'auto-mode-alist '("\\.tpl\\.php\\'" . web-mode))
    (add-to-list 'auto-mode-alist '("\\.[agj]sp\\'" . web-mode))
    (add-to-list 'auto-mode-alist '("\\.as[cp]x\\'" . web-mode))
    (add-to-list 'auto-mode-alist '("\\.erb\\'" . web-mode))
    (add-to-list 'auto-mode-alist '("\\.mustache\\'" . web-mode))
    (add-to-list 'auto-mode-alist '("\\.djhtml\\'" . web-mode))
    (add-to-list 'auto-mode-alist '("\\.hbs\\'" . web-mode)))
#+END_SRC

**** PHP Development
#+BEGIN_SRC emacs-lisp :tangle ~/.emacs
  (use-package php-mode
    :defer
    :config
    (autoload 'php-mode "php-mode-improved" "Major mode for editing php code." t)
    (add-to-list 'auto-mode-alist '("\\.php$" . php-mode))
    (add-to-list 'auto-mode-alist '("\\.inc$" . php-mode)))
#+END_SRC

**** Additional Languages
Various modes helpful for development
#+BEGIN_SRC emacs-lisp :tangle ~/.emacs
  (use-package yaml-mode
    :defer
    :config (add-to-list 'auto-mode-alist '("\\.yml\\'" . yaml-mode)))
  (use-package restclient :defer)
  (use-package groovy-mode :defer)
  (use-package go-mode :defer)
  (use-package emmet-mode
    :defer
    :config
    (add-hook 'sgml-mode-hook 'emmet-mode)
    (add-hook 'css-mode-hook 'emmet-mode)
    (add-hook 'web-mode-hook 'emmet-mode)
    (add-hook 'sass-mode-hook 'emmet-mode))
#+END_SRC

**** Version Control
Magit for version control
#+BEGIN_SRC emacs-lisp :tangle ~/.emacs
  (setenv "PATH" (concat (getenv "PATH") ":/usr/local/git/bin"))
  (setenv "PATH" (concat (getenv "PATH") (concat ":" *node-dir*)))
  (setq exec-path (append exec-path '("/usr/local/git/bin")))
  (setq exec-path (append exec-path (list *node-dir*)))
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle ~/.emacs
  (use-package magit
    :config
    (global-set-key (kbd "C-x g") 'magit-status)
    (add-hook 'magit-status-sections-hook 'magit-insert-stashes))
#+END_SRC

** Theme/UI
*** General Settings
#+BEGIN_SRC emacs-lisp :tangle ~/.emacs
  (use-package zerodark-theme :config (load-theme 'zerodark t))
#+END_SRC

Remove default scrollbars
#+BEGIN_SRC emacs-lisp :tangle ~/.emacs
(scroll-bar-mode -1)
#+END_SRC

Hide the default toolbars
#+BEGIN_SRC emacs-lisp :tangle ~/.emacs
  (menu-bar-mode -1)
  (tool-bar-mode -1)
#+END_SRC

I prefer to see trailing whitespace but not for every mode (e.g. org, elfeed, etc)
#+BEGIN_SRC emacs-lisp :tangle ~/.emacs
  (use-package whitespace
    :config
    (setq-default show-trailing-whitespace t)
    (defun no-trailing-whitespace ()
      (setq show-trailing-whitespace nil))
    (add-hook 'minibuffer-setup-hook              'no-trailing-whitespace)
    (add-hook 'eww-mode-hook                      'no-trailing-whitespace)
    (add-hook 'shell-mode-hook                    'no-trailing-whitespace)
    (add-hook 'mu4e:view-mode-hook                'no-trailing-whitespace)
    (add-hook 'eshell-mode-hook                   'no-trailing-whitespace)
    (add-hook 'help-mode-hook                     'no-trailing-whitespace)
    (add-hook 'term-mode-hook                     'no-trailing-whitespace)
    (add-hook 'slack-message-buffer-mode-hook     'no-trailing-whitespace)
    (add-hook 'mu4e:view-mode-hook                'no-trailing-whitespace)
    (add-hook 'calendar-mode-hook                 'no-trailing-whitespace))
#+END_SRC

Use visual line mode for text wrapping
#+BEGIN_SRC emacs-lisp :tangle ~/.emacs
  (global-visual-line-mode t)
#+END_SRC
*** Custom Colors
**** Shells
  #+begin_src emacs-lisp
    ;; function to switch background color
    (defun buffer-background-switch ()
      (interactive)
      (setq buffer-face-mode-face `(:background "#0a1310" :foreground "#218352"))
      (custom-set-faces '(comint-highlight-prompt ((t (:inherit minibuffer-prompt :foreground "#2cc46c")))))
      (buffer-face-mode 1))

    (add-hook 'shell-mode-hook 'buffer-background-switch)
    (add-hook 'eshell-mode-hook 'buffer-background-switch)
  #+end_src

**** Org Mode
Set Org mode source block background color to dark gray so it stands out from the typical background
#+begin_src emacs-lisp :tangle ~/.emacs
  (custom-set-faces '(org-block ((t (:inherit shadow :background "gray12")))))

#+end_src

Show the asterisks as bullets and set up indentation
#+BEGIN_SRC emacs-lisp :tangle ~/.emacs
  (use-package org-bullets :config (add-hook 'org-mode-hook (lambda () (org-bullets-mode))))
  (add-hook 'org-mode-hook 'org-indent-mode)
#+END_SRC


*** Dashboard
I like a nice big splash screen and I'm partial to the meditating GNU logo.
#+BEGIN_SRC emacs-lisp :tangle ~/.emacs
  (use-package dashboard
    :config
    (dashboard-setup-startup-hook)
    (setq dashboard-startup-banner (concat *dotemacs-dir* "assets/gnu-meditate-scaled.png"))
    (setq dashboard-items '((recents  . 10)))
    (setq dashboard-banner-logo-title ""))
#+END_SRC
*** Highlight line
Helpful for finding the cursor when jumping around
#+BEGIN_SRC emacs-lisp :tangle ~/.emacs
  (global-hl-line-mode +1)
#+END_SRC

*** Ivy Posframe
    #+begin_src emacs-lisp :tangle ~/.emacs
      (use-package ivy-posframe
	:config
	(setq ivy-posframe-display-functions-alist
	      '((swiper          . ivy-posframe-display-at-frame-bottom-left)
		(complete-symbol . ivy-posframe-display-at-point)
		(counsel-M-x     . ivy-posframe-display-at-frame-center)
		(t               . ivy-posframe-display)))
	(ivy-posframe-mode 0)
	(custom-set-faces '(ivy-posframe ((t (:inherit default :background "black"))))))
    #+end_src

*** Modeline
Clean up modeline with diminish
#+BEGIN_SRC emacs-lisp :tangle ~/.emacs
  (use-package diminish)
#+END_SRC

Use the spaceline from spacemacs
#+begin_src emacs-lisp :tangle ~/.emacs
(use-package spaceline
  :config
  (require 'spaceline-config)
  (setq powerline-default-separator (quote wave))
  (spaceline-spacemacs-theme)
  (setq powerline-height 20)
  (set-face-attribute 'mode-line nil :box nil)
  (set-face-attribute 'mode-line-inactive nil :box nil))
#+end_src

Show spaceline icons
#+BEGIN_SRC emacs-lisp :tangle ~/.emacs
    (use-package spaceline-all-the-icons
      :after spaceline
      :config (spaceline-all-the-icons-theme))
  (custom-set-variables
   '(spaceline-all-the-icons-separator-type (quote arrow)))
#+END_SRC

*** Minibuffer
Display the current time and battery indicator
#+BEGIN_SRC emacs-lisp :tangle ~/.emacs
  (setq display-time-24hr-format t)
  (setq display-time-format "%H:%M - %d.%b.%y")
  (display-time-mode 1)
  (display-battery-mode 1)
#+END_SRC

*** Frames
#+BEGIN_SRC emacs-lisp :tangle (if (string-equal system-type "darwin") "~/.emacs")
  (add-to-list 'default-frame-alist '(ns-transparent-titlebar . t))
  (add-to-list 'default-frame-alist '(ns-appearance . dark))

  ;; Autohide the top panel if necessary
  (setq ns-auto-hide-menu-bar t)
  (toggle-frame-maximized)

  (set-face-attribute 'default nil :height 120)
#+END_SRC

#+begin_src emacs-lisp :tangle ~/.emacs
(global-set-key (kbd "<f9>") 'other-frame)
#+end_src
*** Mouse
We'll need to turn off the mouse from time to time
#+BEGIN_SRC emacs-lisp :tangle ~/.emacs
  (use-package disable-mouse :diminish disable-mouse-mode)
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle (if (string-equal system-type "darwin") "~/.emacs")
  (global-disable-mouse-mode)
#+END_SRC

Because linux runs exwm we shouldn't turn the mouse off completely.
#+BEGIN_SRC emacs-lisp :tangle (if (string-equal system-type "gnu/linux") "~/.emacs")
  (add-hook 'lisp-interaction-mode                'disable-mouse-mode)
  (add-hook 'shell-mode-hook                      'disable-mouse-mode)
  (add-hook 'org-src-mode-hook                    'disable-mouse-mode)
  (add-hook 'org-mode-hook                        'disable-mouse-mode)
  (add-hook 'javascript-mode-hook                 'disable-mouse-mode)
  (add-hook 'rjsx-mode-hook                       'disable-mouse-mode)
  (add-hook 'text-mode-hook                       'disable-mouse-mode)
  (add-hook 'web-mode-hook                        'disable-mouse-mode)
  (add-hook 'dired-mode-hook                      'disable-mouse-mode)
  (add-hook 'org-mode-hoook                       'disable-mouse-mode)
  (add-hook 'lisp-interaction-mode-hook           'disable-mouse-mode)
  (add-hook 'emacs-lisp-mode-hook                 'disable-mouse-mode)
  (add-hook 'special-mode-hook                    'disable-mouse-mode)
  (add-hook 'fundamental-mode-hook                'disable-mouse-mode)
  (add-hook 'groovy-mode-hook                     'disable-mouse-mode)
  (add-hook 'ng2-ts-mode-hook                     'disable-mouse-mode)
  (add-hook 'org-agenda-mode-hook                 'disable-mouse-mode)
  (add-hook 'eshell-mode-hook                     'disable-mouse-mode)
  (add-hook 'slack-message-buffer-mode-hook       'disable-mouse-mode)
  (add-hook 'typescript-mode-hook                 'disable-mouse-mode)
  (add-hook 'clojure-mode-hook                    'disable-mouse-mode)
  (add-hook 'repl-mode-hook                       'disable-mouse-mode)
#+END_SRC

*** Symbols
Show symbols by default
#+BEGIN_SRC emacs-lisp :tangle ~/.emacs
  (global-prettify-symbols-mode 1)
#+END_SRC

*** X Window Manager
This section is specific to running emacs as a tiling window manager desktop via EXWM. Source blocks here will if the OS is GNU/Linux.

**** General Setup

Go fullscreen and set the default font size.
#+BEGIN_SRC emacs-lisp :tangle (if (string-equal system-type "gnu/linux") "~/.emacs")
  (set-frame-parameter nil 'fullscreen 'fullboth)
  (set-face-attribute 'default nil :height 140)
  (set-face-attribute 'default nil :font "Inconsolata-14")
#+END_SRC

#+begin_src emacs-lisp :tangle (if (string-equal system-type "darwin") "~/.emacs")
  (set-face-attribute 'default nil :font "Inconsolata-14")
#+end_src

 #+BEGIN_SRC shell
   #!/bin/bash

   # Let java applications know that exwm is a non-reparenting WM
   export _JAVA_AWT_WM_NONREPARENTING=1
   exec emacs
 #+END_SRC

**** EXWM
With EXWM it can act as a complete desktop environment.
#+BEGIN_SRC emacs-lisp
  (use-package exwm)
  (use-package exwm-config
    :ensure nil
    :config
    (exwm-config-default)
    (global-set-key (kbd "C-x O")  'exwm-workspace-switch-to-buffer))
#+END_SRC
***** Multiple Monitor Support

Fortunately EXWM also has support for multiple monitors.
#+BEGIN_SRC emacs-lisp
  (require 'exwm-randr)
  (setq exwm-randr-workspace-output-plist '(0 "eDP1" 1 "DP1-2" 3 "DP1-2"))
  (add-hook 'exwm-randr-screen-change-hook
	    (lambda () (start-process-shell-command "xrandr" nil "xrandr --output eDP1 --mode 2048x1152; xrandr --output eDP1 --mode 2048x1152 --right-of DP1-2 --auto")))
  (exwm-randr-enable)
#+END_SRC

Simple script for waking up second monitor after reattaching
#+BEGIN_SRC emacs-lisp
  (defun jrm/wake-second-monitor ()
      "Turns second monitor off and back on to wake it up. Helpful for exwm + X11 + multiple monitors."
    (interactive)
    (shell-command "xrandr --output DP1-2 --off && xrandr --output DP1-2 --auto"))
  (global-set-key (kbd "C-x C-j m") 'jrm/wake-second-monitor)
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (add-hook 'dashboard-mode-hook (lambda () (shell-command "xrandr --output eDP1 --mode 2048x1152")))
#+END_SRC

**** Applications
***** DMenu Application Launcher
#+BEGIN_SRC emacs-lisp :tangle (if (string-equal system-type "gnu/linux") "~/.emacs")
  (use-package dmenu :bind ("s-SPC" . 'dmenu))
#+END_SRC
***** VLC/Multimedia
Occasionally it's helpful to be able to start, play, pause and exit vlc buffers while never having to leave your current buffer. This is particularly helpful for following along with training videos.
    #+BEGIN_SRC emacs-lisp :tangle (if (string-equal system-type "gnu/linux") "~/.emacs")
      (defvar videoBuffer "video-controller")

      (defun jrm/vlc-start-video-playlist ()
	"Start a video in VLC that can be controlled via emacs"
	(interactive)
	(let ((x (read-directory-name "Enter video directory:")))
	  (get-buffer-create videoBuffer)
	  (shell videoBuffer)
	  (process-send-string videoBuffer "cd ~/\n")
	  (process-send-string videoBuffer (concat "vlc -I rc " x "*.webm\n"))
	  (message "Now playing videos in directory %s." x)))
      (global-set-key (kbd "C-x C-j v s") 'jrm/vlc-start-video-playlist)

      (defun jrm/vlc-pause-video ()
	"Toggle pausing a running vlc stream"
	(interactive)
	(process-send-string videoBuffer "pause\n"))
      (global-set-key (kbd "C-x C-j v p") 'jrm/vlc-pause-video)

      (defun jrm/vlc-go-foward-10-video ()
	"Seek forward X seconds in a playing vlc stream"
	(interactive)
	(process-send-string videoBuffer "seek 10\n"))
      (global-set-key (kbd "C-x C-j v f") 'jrm/vlc-go-foward-10-video)

      (defun jrm/vlc-next-video ()
	"Jump to next video in playlist"
	(interactive)
	(process-send-string videoBuffer "next\n"))
      (global-set-key (kbd "C-x C-j v n") 'jrm/vlc-next-video)

      (defun jrm/vlc-last-video ()
	"Jump to previous video in playlist"
	(interactive)
	(process-send-string videoBuffer "prev\n"))
      (global-set-key (kbd "C-x C-j v l") 'jrm/vlc-last-video)

      (defun jrm/vlc-go-backward-10-video ()
	"Seek forward X seconds in a playing vlc stream"
	(interactive)
	(process-send-string videoBuffer "seek -10\n"))
      (global-set-key (kbd "C-x C-j v r") 'jrm/vlc-go-backward-10-video)

      (defun jrm/vlc-quit-video ()
	"Quit a running vlc stream"
	(interactive)
	(process-send-string videoBuffer "quit\n")
	(process-send-string videoBuffer "exit\n")
	(kill-buffer videoBuffer))
      (global-set-key (kbd "C-x C-j v q") 'jrm/vlc-quit-video)
    #+END_SRC
***** Audio Keys
#+BEGIN_SRC emacs-lisp
  (defun jrm/volume-increase ()
    "Bump up the volume by 5%"
    (interactive)
    (with-temp-buffer (shell-command "/usr/bin/amixer set Master 5%+" t))
    (message "%s" (shell-command-to-string "/usr/bin/amixer get Master")))
  (global-set-key (kbd "<XF86AudioRaiseVolume>") 'jrm/volume-increase)


  (defun jrm/volume-decrease ()
    "Bump down the volume by 5%"
    (interactive)
    (with-temp-buffer (shell-command "/usr/bin/amixer set Master 5%-" t))
    (message "%s" (shell-command-to-string "/usr/bin/amixer get Master")))
  (global-set-key (kbd "<XF86AudioLowerVolume>") 'jrm/volume-decrease)

  (defun jrm/volume-mute-toggle ()
    "Toggle volume mute on/off"
    (interactive)
    (with-temp-buffer (shell-command "/usr/bin/amixer set Master toggle" t))
    (message "%s" (shell-command-to-string "/usr/bin/amixer get Master")))
  (global-set-key (kbd "<XF86AudioMute>") 'jrm/volume-mute-toggle)

#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle (if (string-equal system-type "gnu/linux") "~/.emacs")
  (defun jrm/log-volume () "Send the audio status to the message buffer"
	 (message "%s" (shell-command-to-string (concat *amixer-path* " get Master"))))

  (defun jrm/volume-increase () "Bump up the volume by 5%"
    (interactive)
    (with-temp-buffer (shell-command (concat *amixer-path* " set Master 5%+") t))
    (jrm/log-volume))
  (global-set-key (kbd "<XF86AudioRaiseVolume>") 'jrm/volume-increase)

  (defun jrm/volume-decrease () "Bump down the volume by 5%"
    (interactive)
    (with-temp-buffer (shell-command (concat *amixer-path* " set Master 5%-") t))
    (jrm/log-volume))
  (global-set-key (kbd "<XF86AudioLowerVolume>") 'jrm/volume-decrease)

  (defun jrm/volume-mute-toggle () "Toggle volume mute on/off"
    (interactive)
    (with-temp-buffer (shell-command (concat *amixer-path* " set Master toggle") t))
    (jrm/log-volume))
  (global-set-key (kbd "<XF86AudioMute>") 'jrm/volume-mute-toggle)
#+END_SRC


***** Screenshots
 I took this from Uncle Dave's config. Its a super slick screenshot function for taking both fullscreen as well as region screenshots.
 #+BEGIN_SRC emacs-lisp :tangle (if (string-equal system-type "gnu/linux") "~/.emacs")
   (defun jrm/take-screenshot ()
     "Takes a fullscreenshot of the current workspace"
     (interactive)
     (when window-system
       (cl-loop for i downfrom 3 to 1 do
		(progn
		  (message (concat (number-to-string i) "..."))
		  (sit-for 1)))
       (message "Cheese!")
       (sit-for 1)
       (start-process "screenshot" nil "import" "-window" "root"
		      (concat  *screenshot-dir* (current-time-string) ".png"))
       (message "Screenshot taken!")))
   (global-set-key (kbd "C-x C-j <C-print>") 'jrm/take-screenshot)

   (defun jrm/take-screenshot-region ()
     "Takes a screenshot of a region selected by the user"
     (interactive)
     (when window-system
       (call-process "import" nil nil nil ".newScreenshot.png")
       (call-process "convert" nil nil nil ".newScreenshot.png" "-shave" "1x1"
		     (concat (getenv "HOME") "/Pictures/" (current-time-string) ".png"))
       (call-process "rm" nil nil nil ".newScreenshot.png")))
   (global-set-key (kbd "C-x C-j <print>") 'jrm/take-screenshot-region)
 #+END_SRC
  
***** Lock screen with slock
#+BEGIN_SRC emacs-lisp
    (exwm-input-set-key (kbd "s-l") (lambda () (interactive) (start-process "" nil "/usr/bin/slock")))
  #+END_SRC

***** Interacting with GUI Applications
I find the default way (C-c C-q) of exwm sending keys like ctrl to an async buffer difficult. C-c C-c is much simpler for me.
#+BEGIN_SRC emacs-lisp :tangle
    (define-key exwm-mode-map [?\C-c ?\C-c] 'exwm-input-send-next-key)
  #+END_SRC

** Org Mode
Load some basic minor modes by default
#+BEGIN_SRC emacs-lisp :tangle ~/.emacs 
  (add-hook 'org-mode-hook 'no-trailing-whitespace)
  (add-hook 'org-mode-hook 'flyspell-mode)
#+END_SRC

#+begin_src emacs-lisp :tangle ~/.emacs
  (setq org-hide-emphasis-markers t)
  ;; Copy the visible text (without formatting marks) by default
  ;; (define-key org-mode-map (kbd "M-w") 'org-copy-visible)
  ;; (define-key org-mode-map (kbd "M-W") 'kill-ring-save)
#+end_src
*** General Styling
#+begin_src emacs-lisp :tangle ~/.emacs
  (add-hook 'org-mode-hook (lambda () (variable-pitch-mode t)))
  (custom-set-faces
   '(variable-pitch ((t (:family "Roboto")))))
  (set-face-attribute 'org-table nil :inherit 'fixed-pitch)
  (set-face-attribute 'org-block nil :inherit 'fixed-pitch :height 0.8)
#+end_src

*** Navigation
Setup an easy way to jump to an org headline using org-goto =C-c C-j=
#+BEGIN_SRC elisp :tangle ~/.emacs
  (setq org-goto-interface 'outline-path-completion
	org-goto-max-level 10)

  (setq org-outline-path-complete-in-steps nil)
#+END_SRC

#+begin_src elisp :tangle ~/.emacs
  (global-set-key (kbd "C-o") 'other-window)
  (define-key dired-mode-map (kbd "C-o") 'other-window)
  (define-key rg-mode-map (kbd "C-o") 'other-window)
  (define-key grep-mode-map (kbd "C-o") 'other-window)
  (define-key bookmark-bmenu-mode-map (kbd "C-o") 'other-window)
#+end_src

*** Source Blocks
When evaluating a source code block in org mode do not prompt for input, just run it.
#+BEGIN_SRC emacs-lisp :tangle ~/.emacs
  (setq org-confirm-babel-evaluate nil)
#+END_SRC

Stylistic preferences for using the pre-v9 version of org mode (E.g. [[https://orgmode.org/manual/Easy-templates.html][easy templates]] and how to split the source window when editing, make the source blocks full width.)
#+BEGIN_SRC emacs-lisp :tangle ~/.emacs
  (require 'org-tempo)
  (setq org-src-window-setup 'other-window)

  (custom-set-faces
   '(org-block ((t (:inherit shadow :extend t :background "gray12"))))
   '(org-block-begin-line ((t (:extend t :background "gray12" :foreground "#4a5468" :height 0.9))))
   '(org-block-end-line ((t (:extend t :background "gray12" :foreground "#4a5468" :height 0.9)))))
#+END_SRC

Set the node environment
#+BEGIN_SRC emacs-lisp :tangle ~/.emacs
  (setq org-babel-js-cmd (concat *node-dir* "node"))
#+END_SRC

**** Additional Modes
 Add some export modes for getting content out of org. Not using ~:defer~ here as I'm not sure it's helpful and adding it to ~ob-clojure~ throws a ~Wrong type argument: stringp, :defer~ error.
 #+BEGIN_SRC emacs-lisp :tangle ~/.emacs
   (use-package ox-twbs)
   (use-package ob-rust)
   (use-package ob-restclient)
   (require 'ob-clojure)
   (use-package ob-typescript :diminish typescript-mode)
 #+END_SRC

Allow asynchronous execution of org-babel src blocks so you can keep using emacs during long running scripts
#+BEGIN_SRC emacs-lisp :tangle ~/.emacs
  (use-package ob-async)
#+END_SRC

Load some languages by default
#+BEGIN_SRC emacs-lisp :tangle ~/.emacs
  (add-to-list 'org-src-lang-modes '("js" . "javascript")
	       '("php" . "php"))
  (org-babel-do-load-languages
   'org-babel-load-languages
   '((python . t)
     (js . t)
     (lisp . t)
     (clojure . t)
     (typescript . t)
     (rust . t)
     (sql . t)
     (shell . t)
     (java . t)))
#+END_SRC

I like org source blocks for typescript to use different compiler settings than what ships with ob-typescript. Not sure if there's a better way to do this, but just overwriting the function from the source with the code below using the configuration I prefer.
#+begin_src emacs-lisp :tangle ~/.emacs
  (defun org-babel-execute:typescript (body params)
    "Execute a block of Typescript code with org-babel. This function is called by `org-babel-execute-src-block'"
    (let* ((tmp-src-file (org-babel-temp-file "ts-src-" ".ts"))
	   (tmp-out-file (org-babel-temp-file "ts-src-" ".js"))
	   (cmdline (cdr (assoc :cmdline params)))
	   (cmdline (if cmdline (concat " " cmdline) ""))
	   (jsexec (if (assoc :wrap params) ""
		     (concat " ; node " (org-babel-process-file-name tmp-out-file)))))
      (with-temp-file tmp-src-file (insert body))
      (let ((results (org-babel-eval (format "tsc %s --lib 'ES7,DOM' -out %s %s %s"
					     cmdline
					     (org-babel-process-file-name tmp-out-file)
					     (org-babel-process-file-name tmp-src-file)
					     jsexec) ""))
	    (jstrans (with-temp-buffer
		       (insert-file-contents tmp-out-file)
		       (buffer-substring-no-properties (point-min) (point-max)))))
	(if (eq jsexec "") jstrans results))))
#+end_src

For org-babel's clojure backend use cider rather than the default slime
#+BEGIN_SRC emacs-lisp  ~/.emacs
  (setq org-babel-clojure-backend 'cider)
#+END_SRC

*** Org Capture
Customize org capture to my liking
#+BEGIN_SRC emacs-lisp :tangle ~/.emacs
  (global-set-key (kbd "C-c c") 'org-capture)
  (setq org-capture-templates
	'((" " "TODOs ==============================" entry (file "") "")
	  ("w" "Work Todo" entry (file+headline "~/org/work/TeachForward/teachforward.org" "Todos")
	   "** IMMEDIATE TODO %? :tf:\n  %i\n  %a")
	  ("l" "Personal Todo\n" entry (file "~/org/personal/personal.org")
	   "*** TODO %? :personal:\n  %i\n  %a")
	  (" " "PROGRAMMING SNIPPETS ===============" entry (file "") "")
	  ("j" "JS Snippet" entry (file "~/org/personal/research/development/js/Javascript-snippets.org")
	   "* \n #+BEGIN_SRC js\n%?\n#+END_SRC\n\n[Date: %<%Y-%d-%m>]" :prepend t)
	  ("t" "TS Snippet\n" entry (file "~/org/personal/research/development/js/Javascript-snippets.org")
	   "* \n #+BEGIN_SRC typescript\n%?\n#+END_SRC\n\n[Date: %<%Y-%d-%m>]" :prepend t)
	  (" " "MEETINGS ===========================" entry (file "") "")
	  ("m" "Meeting\n" entry (file+headline "~/org/work/TeachForward/teachforward.org" "Meetings")
	   "** MEETING with %? :MEETING:\n  %i\n"  :clock-in t :clock-resume t)))

#+END_SRC

**** Global Org Capture
Simple command to open emacs (assumes it's already running) and launch org capture in a new frame. This can be bound to a global key sequence.
#+BEGIN_SRC bash
emacsclient -ne "(make-capture-frame)"
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle ~/.emacs
  (server-start)

  (defadvice org-capture-finalize 
      (after delete-capture-frame activate)
    "Advise capture-finalize to close the frame"
    (if (equal "capture" (frame-parameter nil 'name))
	(delete-frame)))

  (defadvice org-capture-destroy
      (after delete-capture-frame activate)
    "Advise capture-destroy to close the frame"
    (if (equal "capture" (frame-parameter nil 'name))
	(delete-frame)))

  (use-package noflet
    :ensure t )
  (defun make-capture-frame ()
    "Create a new frame and run org-capture."
    (interactive)
    (make-frame '((name . "capture")))
    (select-frame-by-name "capture")
    (delete-other-windows)
    (noflet ((switch-to-buffer-other-window (buf) (switch-to-buffer buf)))
      (org-capture)))

#+END_SRC

Helpful for bridging org and jira.
#+BEGIN_SRC emacs-lisp :tangle ~/.emacs
  (use-package ox-jira)
#+END_SRC

*** Remote Syncing
This attempts to sync an org file on save if it detects the file is in the ~*org-dir*~ directory.
#+BEGIN_SRC emacs-lisp :tangle ~/.emacs
  (defun jrm/git-auto-sync ()
    "Automatically stages, commits, pulls, and pushes the current branch's upstream settings. Commit message is current timestamp. Depends on Magit."
    (interactive)
    (if (string-match-p (regexp-quote *org-dir*) (file-name-directory buffer-file-name))
	(progn 
	  (magit-stage-modified)
	  (magit-run-git-with-editor "commit" "-m" (format-time-string "%a %d %b %Y %H:%M:%S %Z"))
	  (magit-run-git-async "pull")
	  (magit-run-git-async "push"))))

  (add-hook 'org-mode-hook (lambda () (add-hook 'after-save-hook 'jrm/git-auto-sync nil t)))
#+END_SRC

*** LaTex
Use xelatex for more latex options like fontspec
#+BEGIN_SRC elisp :tangle ~/.emacs
(setq org-latex-compiler "xelatex")
#+END_SRC

*** TODOs/Agenda
Setup standard todo keywords
#+BEGIN_SRC emacs-lisp :tangle ~/.emacs
  (setq org-use-fast-todo-selection t)
  (setq org-todo-keywords
	'((sequence "IMMEDIATE TODO(t!)" "|" "DONE(d!)")
      (sequence "WORKFLOW TODO(w@/!)" "SOON(s@/!)" "|" "SOMEDAY(S@/!)")))
  ;; Custom colors for the keywords
  (setq org-todo-keyword-faces
	'(("IMMEDIATE TODO" :foreground "red" :weight bold)
      ("DONE" :foreground "forest green" :weight bold)
      ("WORKFLOW TODO" :foreground "#61afef" :weight bold)
      ("SOON" :foreground "#da8548" :weight bold)
      ("SOMEDAY" :foreground "#9963ad" :weight bold)))
#+END_SRC

File locations for org agenda
#+BEGIN_SRC emacs-lisp :tangle ~/.emacs
  (global-set-key (kbd "C-c a") 'org-agenda)
  (setq org-agenda-files (list "~/org/work/TeachForward/"))
#+END_SRC

*** Org Export
#+BEGIN_SRC emacs-lisp :tangle ~/.emacs
  (custom-set-variables
   '(org-export-backends '(ascii html icalendar latex md odt)))
#+END_SRC
*** Markdown
#+BEGIN_SRC emacs-lisp
  (use-package grip-mode
    :ensure-system-package (grip . "pip install grip"))
#+END_SRC
** Shells
By default just use bash for all shells
#+BEGIN_SRC emacs-lisp :tangle ~/.emacs
  (defvar my-term-shell "/bin/bash")
  (defadvice ansi-term (before force-bash)
    (interactive (list my-term-shell)))
  (ad-activate 'ansi-term)
#+END_SRC

Make shells interactive (i.e. M-!, or source blocks in org)
#+BEGIN_SRC emacs-lisp :tangle ~/.emacs
  (setq shell-command-switch "-c")
#+END_SRC

Fixes emacs and osx path issues.
#+BEGIN_SRC emacs-lisp
  (use-package exec-path-from-shell
    :config
    (when (memq window-system '(mac ns x))
      (exec-path-from-shell-initialize)))
#+END_SRC

** Consuming Content
*** Elfeed
Many thanks to [[http://pragmaticemacs.com/emacs/read-your-rss-feeds-in-emacs-with-elfeed/][pragmatic emacs' post]] for guidance on this setup.
#+BEGIN_SRC emacs-lisp :tangle ~/.emacs
  (use-package elfeed-org
    :config (elfeed-org) (setq rmh-elfeed-org-files (list (concat *org-dir* "personal/elfeed.org"))))

  (defun jrm/elfeed-show-all ()
    (interactive)
    (bookmark-maybe-load-default-file)
    (bookmark-jump "elfeed-all"))
  (defun jrm/elfeed-show-development ()
    (interactive)
    (bookmark-maybe-load-default-file)
    (bookmark-jump "elfeed-development"))
  (defun jrm/elfeed-show-news ()
    (interactive)
    (bookmark-maybe-load-default-file)
    (bookmark-jump "elfeed-news"))
  (defun jrm/elfeed-show-emacs ()
    (interactive)
    (bookmark-maybe-load-default-file)
    (bookmark-jump "elfeed-emacs"))

  (defun jrm/elfeed-load-db-and-open ()
    "Wrapper to load the elfeed db from disk before opening"
    (interactive)
    (elfeed-db-load)
    (elfeed)
    (elfeed-search-update--force))

  (defun jrm/elfeed-save-db-and-bury ()
    "Wrapper to save the elfeed db to disk before burying buffer"
    (interactive)
    (elfeed-db-save)
    (quit-window))

  (use-package elfeed
    :defer
    :bind (:map elfeed-search-mode-map
		("A" . jrm/elfeed-show-all)
		("E" . jrm/elfeed-show-emacs)
		("D" . jrm/elfeed-show-development)
		("N" . jrm/elfeed-show-news)
		("q" . jrm/elfeed-save-db-and-bury)))

  (global-set-key (kbd "C-x e") 'jrm/elfeed-load-db-and-open)
#+END_SRC

Sometimes it's helpful to hide images for certain posts.
#+BEGIN_SRC emacs-lisp :tangle ~/.emacs
  (defun jrm/elfeed-show-hide-images ()
    (interactive)
    (let ((shr-inhibit-images t))
      (elfeed-show-refresh)))
  (global-set-key (kbd "C-x C-j e") 'jrm/elfeed-show-hide-images)
#+END_SRC

** Helpful Utility Functions and settings
Most of the functions in this section are bound to ~C-x C-j~ prefix key.
*** Copy Entire Buffer easily
#+BEGIN_SRC emacs-lisp :tangle ~/.emacs
  (defun jrm/copy-all ()
    "Copy the current buffer without loosing your place"
    (interactive)
    (let ((original-position (point)))
      (mark-whole-buffer)
      (kill-ring-save 0 0 t)
      (goto-char original-position)
      (message "Buffer contents yanked.")))
  (global-set-key (kbd "C-x C-j C-c") 'jrm/copy-all)
#+END_SRC

*** Quickly Change Font Sizes
I find myself need specific font sizes for different scenarios, i.e. projecting, screen-sharing on conference calls, etc. So, binding these to a quick way to toggle through them. 

/Note: there might be a better way to handle this but things like M-+/M-- won't zoom things like line numbers, etc./
#+BEGIN_SRC emacs-lisp :tangle ~/.emacs
  (defvar jrm/screens-alist '((?0 "xsmall" (lambda () (set-face-attribute 'default nil :height 70) 'default))
			      (?1 "small" (lambda () (set-face-attribute 'default nil :height 110) 'default))
			      (?2 "medium" (lambda () (set-face-attribute 'default nil :height 120) 'proj))
			      (?3 "large" (lambda () (set-face-attribute 'default nil :height 140) 'proj))
			      (?4 "xtra-large" (lambda () (set-face-attribute 'default nil :height 160) 'projLg))
			      (?5 "xxtra-large" (lambda () (set-face-attribute 'default nil :height 190) 'projLg))
			      (?6 "xxxtra-large" (lambda () (set-face-attribute 'default nil :height 210) 'projLg)))
    "List that associates number letters to descriptions and actions.")
  (defun jrm/adjust-font-size ()
    "Lets the user choose the the font size and takes the corresponding action.
  Returns whatever the action returns."
    (interactive)
    (let ((choice (read-char-choice
		   (mapconcat (lambda (item) (format "%c: %s" (car item) (cadr item)))
			      jrm/screens-alist "; ")
		   (mapcar #'car jrm/screens-alist))))
      (funcall (nth 2 (assoc choice jrm/screens-alist)))))
  (global-set-key (kbd "C-x C-j p")  'jrm/adjust-font-size)
#+END_SRC

*** Copy current file path
Lifted from (http://ergoemacs.org/emacs/emacs_copy_file_path.html)
#+BEGIN_SRC emacs-lisp :tangle ~/.emacs
  (defun jrm/copy-file-path (&optional *dir-path-only-p)
    "Copy the current buffer's file path or dired path to `kill-ring'.
  Result is full path."
    (interactive "P")
    (let ((-fpath
	   (if (equal major-mode 'dired-mode)
	       (expand-file-name default-directory)
	     (if (buffer-file-name)
		 (buffer-file-name)
	       (user-error "Current buffer is not associated with a file.")))))
      (kill-new
       (if *dir-path-only-p
	   (progn
	     (message "Directory path copied: 「%s」" (file-name-directory -fpath))
	     (file-name-directory -fpath))
	 (progn (message "File path copied: 「%s」" -fpath) -fpath )))))
#+END_SRC

*** Basic debugging
A bit of helpful debugging for a few modes
#+BEGIN_SRC emacs-lisp
  (defun jrm/insert-debug-log ()
    "Inserts logging based on mode"
    (interactive)
    (when (or (equal major-mode 'js-mode) (equal major-mode 'js2-mode) (equal major-mode 'typescript-mode) (equal major-mode 'ng2-ts-mode) (equal major-mode 'rjsx-mode))
      (insert "console.log(``);")
      (backward-char 3))
    (when (equal major-mode 'clojure-mode)
      (insert "(println (format \"%s\" ))")
      (backward-char 2))
    (when (equal major-mode 'emacs-lisp-mode)
      (insert "(message (format \"%s\" ))")
      (backward-char 2)))

  (global-set-key (kbd "C-x C-j d") 'jrm/insert-debug-log)
#+END_SRC

*** Async Shell Command 
     #+begin_src emacs-lisp :tangle ~/.emacs.d/jrm-util.el
       (defun jrm/async-callback-run-callback (process signal cb)
	 (interactive)
	 (when (memq (process-status process) '(exit signal))
	   (cb)
	   (shell-command-sentinel process signal)))

       (defun jrm/async-callback (cmd cb)
	 (let* ((output-buffer (generate-new-buffer "*Custom Shell Command*"))
		(proc (progn
			(async-shell-command cmd output-buffer)
			(get-buffer-process output-buffer))))
	   (if (process-live-p proc)
	       (set-process-sentinel proc cb #'jrm/async-callback-run-callback)
	     (message "No process running."))))

      #+end_src

*** Grep customizations
For various reasons ripgrep does not work with all the projects I need so customizing grep to my liking
#+begin_src emacs-lisp :tangle ~/.emacs
(setq grep-find-ignored-directories (quote ("SCCS" "RCS" "CVS" "MCVS" ".src" ".svn" ".git" ".hg" ".bzr" "_MTN" "_darcs" "{arch}" "node_modules" "vendor" "dist" "coverage")))
#+end_src

** Final Pieces
*** Remap Key sequences
#+BEGIN_SRC emacs-lisp :tangle ~/.emacs
  (global-set-key (kbd "s-u") '(lambda () (interactive) (revert-buffer t (not (buffer-modified-p)) t)))
#+END_SRC

*** Last Line
#+BEGIN_SRC emacs-lisp :tangle ~/.emacs
  (provide '.emacs)
#+END_SRC



